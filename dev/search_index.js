var documenterSearchIndex = {"docs":
[{"location":"pmops.html#Operations-on-periodic-matrices","page":"Periodic Matrix Operations","title":"Operations on periodic matrices","text":"","category":"section"},{"location":"pmops.html","page":"Periodic Matrix Operations","title":"Periodic Matrix Operations","text":"Base.:-(A::PeriodicArray)\nLinearAlgebra.inv\nBase.transpose\nBase.adjoint\nopnorm\ntr\nBase.:+\nBase.:-(A::PeriodicArray, B::PeriodicArray)\nBase.:*\npmcopy\nhorzcat\nvertcat\nblockdiag\nblockut\niszero\nisconstant\nBase.isequal\nBase.isapprox\nissymmetric","category":"page"},{"location":"pmops.html#Base.:--Tuple{PeriodicArray}","page":"Periodic Matrix Operations","title":"Base.:-","text":"-(A)\n\nUnary minus operator. \n\n\n\n\n\n","category":"method"},{"location":"pmops.html#Base.inv","page":"Periodic Matrix Operations","title":"Base.inv","text":"inv(A)\n\nPeriodic matrix inversion.  Computes the periodic matrix Ainv such that A * Ainv = Ainv*A = I, where I is the identity matrix. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Base.transpose","page":"Periodic Matrix Operations","title":"Base.transpose","text":"transpose(A)\n\nTranspose of a periodic matrix.  \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Base.adjoint","page":"Periodic Matrix Operations","title":"Base.adjoint","text":"adjoint(A) or A'\n\nAdjoint of a periodic matrix (equivalent to transpose). \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#LinearAlgebra.opnorm","page":"Periodic Matrix Operations","title":"LinearAlgebra.opnorm","text":"opnorm(A,p::Real=2) -> Anorm\n\nCompute the point-wise time-dependent operator norm (or matrix norm) induced by the vector p-norm, where valid values of p are 1, 2, or Inf.  For a periodic matrix A(t), the resulting Anorm(t) is a periodic vector of same type as A, such that Anorm(t) is the p-norm of A(t) for each t. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#LinearAlgebra.tr","page":"Periodic Matrix Operations","title":"LinearAlgebra.tr","text":"tr(A) -> Atr\n\nCompute the point-wise trace of periodic matrix.  For a periodic matrix A(t), the resulting Atr(t) is a periodic vector of same type as A, such that Atr(t) is the trace of A(t) for each t. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Base.:+","page":"Periodic Matrix Operations","title":"Base.:+","text":"+(A, B)\n\nPeriodic matrix addition. One of arguments may be a constant matrix or a uniform scaling.  A and B may have different, but commensurate periods.\n\nWhen adding continuous-time periodic mtrices, if one of arguments is of type PeriodicFunctionMatrix,  then the result is also of type PeriodicFunctionMatrix. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Base.:--Tuple{PeriodicArray, PeriodicArray}","page":"Periodic Matrix Operations","title":"Base.:-","text":"-(A, B)\n\nPeriodic matrix substraction. One of arguments may be a constant matrix or a uniform scaling.  A and B may have different, but commensurate periods.\n\nWhen substracting continuous-time periodic mtrices, if one of arguments is of type PeriodicFunctionMatrix,  then the result is also of type PeriodicFunctionMatrix. \n\n\n\n\n\n","category":"method"},{"location":"pmops.html#Base.:*","page":"Periodic Matrix Operations","title":"Base.:*","text":"*(A, B)\n\nPeriodic matrix multiplication. One of arguments may be a constant matrix, a scalar or a uniform scaling.  A and B may have different, but commensurate periods.\n\nWhenmultiplying continuous-time periodic mtrices, if one of arguments is of type PeriodicFunctionMatrix,  then the result is also of type PeriodicFunctionMatrix. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmcopy","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmcopy","text":"pmcopy(A)\n\nCreate a copy of the periodic matrix A. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.horzcat","page":"Periodic Matrix Operations","title":"PeriodicMatrices.horzcat","text":"horzcat(A, B)\nhcat(A,B)\n\nHorizontal concatenation of two periodic matrices. Equivalent to the syntax [A B]. A and B may have different, but commensurate periods. One of arguments may be a constant matrix.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.vertcat","page":"Periodic Matrix Operations","title":"PeriodicMatrices.vertcat","text":"vertcat(A, B)\nvcat(A,B)\n\nVertical concatenation of two periodic matrices. Equivalent to the syntax [A; B]. A and B may have different, but commensurate periods.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.blockdiag","page":"Periodic Matrix Operations","title":"PeriodicMatrices.blockdiag","text":"blockdiag(A, B)\n\nBlock diagonal appending of two periodic matrices.  A and B may have different, but commensurate periods.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.blockut","page":"Periodic Matrix Operations","title":"PeriodicMatrices.blockut","text":"blockut(A, B, C) -> D\n\nBlock upper triangular appending of periodic matrices A, B and C.  The resulting D is constructed as D = [A B; 0 C].  A, B and C may have different, but commensurate periods.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Base.iszero","page":"Periodic Matrix Operations","title":"Base.iszero","text":"iszero(A)\n\nExact equality check with a zero periodic matrix.     \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.isconstant","page":"Periodic Matrix Operations","title":"PeriodicMatrices.isconstant","text":"isconstant(A)\n\nConstancy check of a periodic matrix.     \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Base.isequal","page":"Periodic Matrix Operations","title":"Base.isequal","text":"isequal(A, B)\n\nExact equality check of two periodic matries. isequal(A,B) is equivalent to the syntax A == B. A and B must have equal subperiods.    \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Base.isapprox","page":"Periodic Matrix Operations","title":"Base.isapprox","text":"isapprox(A, B; rtol::Real = sqrt(eps(Float64)), atol::Real = 0)\n\nInexact equality comparison of two periodic matries. isaprox(A,B) is equivalent to the syntax A ≈ B. A and B must have equal subperiods. One of arguments may be an uniform scaling.   \n\natol and rtol are the absolute tolerance and relative tolerance, respectively, to be used for comparison.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#LinearAlgebra.issymmetric","page":"Periodic Matrix Operations","title":"LinearAlgebra.issymmetric","text":"issymmetric(A)\n\nSymmetry check of a periodic matrix.     \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#Operations-on-continuous-time-periodic-matrices","page":"Periodic Matrix Operations","title":"Operations on continuous-time periodic matrices","text":"","category":"section"},{"location":"pmops.html","page":"Periodic Matrix Operations","title":"Periodic Matrix Operations","text":"\nnorm(A::Union{HarmonicArray, PeriodicFunctionMatrix}, p::Real; rtol)\ntrace(A::Union{HarmonicArray, PeriodicFunctionMatrix}; rtol)\npmderiv\npmrand(n::Int64, m::Int64, period::Real; nh)","category":"page"},{"location":"pmops.html#LinearAlgebra.norm-Tuple{Union{HarmonicArray, PeriodicFunctionMatrix}, Real}","page":"Periodic Matrix Operations","title":"LinearAlgebra.norm","text":"norm(A, p::Real=2) \nnorm(A::PeriodicFunctionMatrix, p::Real=2; rtol=sqrt(eps()), atol = 1000*eps())\n\nCompute the p-norm of the time-dependent Frobenius-norm of a continuous-time periodic matrix over one period.  For a continuous-time periodic matrix A(t), the resulting Anorm is the p-norm of the time-varying Frobenius norm of A(t).  The involved time integrals are evaluated using the adaptive Gauss-Kronrod quadrature with a relative error tolerance rtol and an absolute tolerance atol. For p = Inf, the computation involves the minimization of the Frobenius norm of A(t) using Brent's method.   \n\nNote: For periodic matrices of PeriodicTimeSeriesMatrix and PeriodicSwitchingMatrix types,  the existing implicit time griding is employed to evaluate the involved time integrals using the rectangle method. \n\n\n\n\n\n","category":"method"},{"location":"pmops.html#PeriodicMatrices.trace-Tuple{Union{HarmonicArray, PeriodicFunctionMatrix}}","page":"Periodic Matrix Operations","title":"PeriodicMatrices.trace","text":"trace(A; rtol=sqrt(eps)) -> Atrace\n\nCompute the trace of a continuous-time periodic matrix over one period.  For a continuous-time periodic matrix A(t), the resulting Atrace is the mean value of the integral of the point-wise trace over a complete period.  The involved time integral are evaluated using the adaptive Gauss-Kronrod quadrature with a relative error tolerance rtol. \n\n\n\n\n\n","category":"method"},{"location":"pmops.html#PeriodicMatrices.pmderiv","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmderiv","text":"pmderiv(A::PeriodicFunctionMatrix; h:Union{Real,Missing} = missing, method = \"cd\", discont = false) \npmderiv(A::PeriodicTimeSeriesMatrix; h:Union{Real,Missing} = missing, method = \"cd\", discont = false) \npmderiv(A::PeriodicSwitchingMatrix; h:Union{Real,Missing} = missing, method = \"cd\", discont = false)\n\nCompute the derivative of a continuous-time periodic matrix using finite difference formulas. By default method = \"cd\", in which case  the central difference formula is used for approximating the derivative.  If method = \"4d\", a fourth order finite difference formula is used for higher accuracy. If method = \"\", the forward difference formula is used if the  time difference h is missing or h > 0, and a backward difference formula is used if h < 0. If discont = true, then initial discountinuities at t = 0 and  terminal discountinuities at tsub := A.period/A.nperiod (the subperiod) are  avoided by using the forward or backward differentiation formulas at t =  0 and at t = tsub, respectively.  This approach generally leads to lower accuracy estimations at t = 0 and t = tsub.   \n\nNote: To allow the application of the finite difference approximations to periodic matrices of types PeriodicTimeSeriesMatrix and PeriodicSwitchingMatrix,  these are converted to PeriodicFunctionMatrix type. Due to inherent discountinuities of these representations, the accuracy of derivate estimations is usualy poor. To increase the accuracy, it is recommended to perform these conversions before calling the pmderiv function, by employing splines based interpolation formulas,  as provided by the function ts2pfm.  \n\n\n\n\n\npmderiv(A::HarmonicArray)\n\nCompute the derivative of a continuous-time periodic matrix in harmonic represention.     \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmrand-Tuple{Int64, Int64, Real}","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmrand","text":"pmrand(::Type{PM}, n, m[, period = 2pi]; nh = 1) \npmrand(::Type{PM{:c,T}}, n, m[, period = 2pi]; nh = 1) \npmrand(n, m[, period = 2pi]; nh = 1) \npmrand(PeriodicTimeSeriesMatrix, n, m[, period = 2pi]; ns = 1) \npmrand(PeriodicTimeSeriesMatrix{:c,T}, n, m[, period = 2pi]; ns = 1) \npmrand(PeriodicSwitchingMatrix, n, m[, period = 2pi]; ts = [0]) \npmrand(PeriodicSwitchingMatrix{:c,T}, n, m[, period = 2pi]; ts = [0])\n\nGenerate a random n×m continuous-time periodic matrix of type PM or PM{:c,T} with period  period (default:  period = 2pi). PM specifies the resulting type of the generated periodic matrix. For PM = HarmonicArray, or PM = PeriodicFunctionMatrix, or PM = PeriodicSymbolicMatrix or PM = FourierFunctionMatrix, the resulting periodic matrix corresponds  to a random harmonic representation with  nh harmonic components (default:  nh = 1).  The type  T of matrix elements can be specified using, e.g. HarmonicArray{:c,T} instead HarmonicArray,  which assumes by default T = Float64. If PM is omitted, then by default PM = HarmonicArray.\n\nFor PM = PeriodicTimeSeriesMatrix, ns specifies the number of component matrices.\n\nFor PM = PeriodicSwitchingMatrix, the vector ts specifies the switching times. \n\n\n\n\n\n","category":"method"},{"location":"pmops.html#Operations-on-discrete-time-periodic-matrices","page":"Periodic Matrix Operations","title":"Operations on discrete-time periodic matrices","text":"","category":"section"},{"location":"pmops.html","page":"Periodic Matrix Operations","title":"Periodic Matrix Operations","text":"Base.reverse\nnorm(A::PeriodicArray)\ntrace(A::PeriodicArray)\npmshift\npmsymadd!\npmata\npmaat\npmrand(::Type{PM}, m::Vector{Int64}, n::Vector{Int64}, period::Real) where PM<:PeriodicMatrix\npmrand(::Type{T}, m::Vector{Int64}, n::Vector{Int64}, period::Real) where T","category":"page"},{"location":"pmops.html#Base.reverse","page":"Periodic Matrix Operations","title":"Base.reverse","text":"reverse(A)\n\nReverse the order of elements of a discrete-time periodic matrix. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#LinearAlgebra.norm-Tuple{PeriodicArray}","page":"Periodic Matrix Operations","title":"LinearAlgebra.norm","text":"norm(A,p::Real=2) -> Anorm\n\nCompute the Frobenius-norm of a discrete-time periodic matrix.  For a discrete-time periodic matrix A(t), the resulting Anorm is the p-norm of the vector of Frobenius norms of each component of A. \n\n\n\n\n\n","category":"method"},{"location":"pmops.html#PeriodicMatrices.trace-Tuple{PeriodicArray}","page":"Periodic Matrix Operations","title":"PeriodicMatrices.trace","text":"trace(A) -> Atrace\n\nCompute the trace of periodic matrix.  For a periodic matrix A(t), the resulting Atrace is the sum of point-wise traces over a complete period (see tr. \n\n\n\n\n\n","category":"method"},{"location":"pmops.html#PeriodicMatrices.pmshift","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmshift","text":"pmshift(A[,k = 1])\n\nCircular shifting of the components of a discrete-time periodic matrix A with k positions. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmsymadd!","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmsymadd!","text":"pmsymadd!(A, α = 1)\n\nCompute for a discrete-time periodic matrix A the symmetric matrix α*(A+A') in place. \n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmata","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmata","text":"pmata(A)\n\nCompute for a discrete-time periodic matrix A the symmetric matrix transpose(A)*A. \n\nNote: This function is available only for periodic matrices of types PeriodicArray and PeriodicMatrix.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmaat","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmaat","text":"pmaat(A)\n\nCompute for a discrete-time periodic matrix A the symmetric matrix A*transpose(A). \n\nNote: This function is available only for periodic matrices of types PeriodicArray and PeriodicMatrix.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmrand-Union{Tuple{PM}, Tuple{Type{PM}, Vector{Int64}, Vector{Int64}, Real}} where PM<:PeriodicMatrix","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmrand","text":"pmrand(::Type{PM}, n::Int, m::Int[, period = 10]; ns = 1) \npmrand(::Type{PM{:d,T}}, n::Int, m::Int[, period = 10]; ns = 1) \npmrand(::Type{PM}, n::Vector{Int}, m::Vector{Int}[, period = 1]) \npmrand(SwitchingPeriodicMatrix, n, m[, period = 10]; ns = [period]) \npmrand(SwitchingPeriodicArray, n, m[, period = 10]; ns = [period])\n\nGenerate a random n×m discrete-time periodic matrix of type PM or PM{:d,T} with period  period (default:  period = 10) with  ns component matrices (default: ns = 1).  If PM = PeriodicMatrix or PM = PeriodicArray, ns specifies the number of component matrices (default: ns = 10). If PM = PeriodicMatrix, then two integer vectors n and m containing the row and column dimensions of the the component matrices, respectively, can be used to specify periodic matrices with time-varying dimensions. \n\nIf PM = SwitchingPeriodicMatrix or PM = SwitchingPeriodicArray, the integer vector ns specifies the switching moments (default: ns = [period]). The typeTof matrix elements can be specified using, e.g.PeriodicMatrix{:d,T}insteadPeriodicMatrix,  which assumes by defaultT = Float64`.\n\n\n\n\n\npmrand([::Type{T},] m::Vector{Int},n::Vector{Int}[, period = 10])\n\nGenerate a random discrete-time periodic matrix of type  PeriodicMatrix with period  period (default:  period = 10).  The time-varying row and column dimensions of component matrices are specified by the integer vectors m and n, respectively. T is the type of matrix elements, which assumes by default value T = Float64 if omitted.\n\n\n\n\n\n","category":"method"},{"location":"pmops.html#PeriodicMatrices.pmrand-Union{Tuple{T}, Tuple{Type{T}, Vector{Int64}, Vector{Int64}, Real}} where T","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmrand","text":"pmrand([::Type{T},] m::Vector{Int},n::Vector{Int}[, period = 10])\n\nGenerate a random discrete-time periodic matrix of type  PeriodicMatrix with period  period (default:  period = 10).  The time-varying row and column dimensions of component matrices are specified by the integer vectors m and n, respectively. T is the type of matrix elements, which assumes by default value T = Float64 if omitted.\n\n\n\n\n\n","category":"method"},{"location":"pmops.html#Operations-with-symmetric-periodic-matrices","page":"Periodic Matrix Operations","title":"Operations with symmetric periodic matrices","text":"","category":"section"},{"location":"pmops.html","page":"Periodic Matrix Operations","title":"Periodic Matrix Operations","text":"pmmulsym\npmtrmulsym\npmmultrsym\npmmuladdsym\npmmultraddsym\npmmuladdtrsym","category":"page"},{"location":"pmops.html#PeriodicMatrices.pmmulsym","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmmulsym","text":"pmmulsym(B, C, β)\n\nCompute the symmetric periodic matrix β*B*C, where β is a real scalar  and the product B*C is known to be symmetric.  All matrix arguments may be constant matrices as well.\n\nNote: This function is available only for periodic matrices of types PeriodicArray, PeriodicMatrix, PeriodicFunctionMatrix and HarmonicArray.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmtrmulsym","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmtrmulsym","text":"pmtrmulsym(B, C, β)\n\nCompute the symmetric periodic matrix β*B'*C, where β is a real scalar and the product B'*C is known to be symmetric.  All matrix arguments may be constant matrices as well.\n\nNote: This function is available only for periodic matrices of types PeriodicArray, PeriodicMatrix, PeriodicFunctionMatrix and HarmonicArray.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmmultrsym","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmmultrsym","text":"pmmultrsym(B, C, β)\n\nCompute the symmetric periodic matrix β*B*C', where β is a real scalar  and the product B*C' is known to be symmetric.  All matrix arguments may be constant matrices as well.\n\nNote: This function is available only for periodic matrices of types PeriodicArray, PeriodicMatrix, PeriodicFunctionMatrix and HarmonicArray.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmmuladdsym","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmmuladdsym","text":"pmmuladdsym(A, B, C, α, β)\n\nCompute the symmetric periodic matrix α*A + β*B*C, where α and β are real scalars,  A is a symmetrix periodic matrix and the product B*C is known to be symmetric.  All matrix arguments may be constant matrices as well.\n\nNote: This function is available only for periodic matrices of types PeriodicArray, PeriodicMatrix, PeriodicFunctionMatrix and HarmonicArray.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmmultraddsym","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmmultraddsym","text":"pmmultraddsym(A, B, C, α, β)\n\nCompute the symmetric periodic matrix α*A + β*B'*C, where α and β are real scalars,  A is a symmetrix periodic matrix and the product B'*C is known to be symmetric.  All matrix arguments may be constant matrices as well.\n\nNote: This function is available only for periodic matrices of types PeriodicArray, PeriodicMatrix, PeriodicFunctionMatrix and HarmonicArray.\n\n\n\n\n\n","category":"function"},{"location":"pmops.html#PeriodicMatrices.pmmuladdtrsym","page":"Periodic Matrix Operations","title":"PeriodicMatrices.pmmuladdtrsym","text":"pmmuladdtrsym(A, B, C, α, β)\n\nCompute the symmetric periodic matrix α*A + β*B*C', where α and β are real scalars,  A is a symmetrix periodic matrix and the product B*C' is known to be symmetric.  All matrix arguments may be constant matrices as well.\n\nNote: This function is available only for periodic matrices of types PeriodicArray, PeriodicMatrix, PeriodicFunctionMatrix and HarmonicArray.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#SLICOT-periodic-system-utilities","page":"SLICOT Based Wrappers","title":"SLICOT periodic system utilities","text":"","category":"section"},{"location":"slicot.html","page":"SLICOT Based Wrappers","title":"SLICOT Based Wrappers","text":"PeriodicMatrices.SLICOTtools.mb03vd!\nPeriodicMatrices.SLICOTtools.mb03vy!\nPeriodicMatrices.SLICOTtools.mb03wd!\nPeriodicMatrices.SLICOTtools.mb03vw!\nPeriodicMatrices.SLICOTtools.mb03bd!\nPeriodicMatrices.SLICOTtools.mb03kd!","category":"page"},{"location":"slicot.html#PeriodicMatrices.SLICOTtools.mb03vd!","page":"SLICOT Based Wrappers","title":"PeriodicMatrices.SLICOTtools.mb03vd!","text":"mb03vd!(n::Integer, p::Integer, ilo::Integer, ihi::Integer, A::Array{Float64, 3}, tau::AbstractMatrix{Float64}) -> info::Int64\n\nReduce a product of p real general matrices A = A_1*A_2*...*A_p to upper Hessenberg form, H = H_1*H_2*...*H_p, where H_1 is upper Hessenberg, and H_2, ..., H_p are upper triangular, by using orthogonal similarity transformations on A,\n\n    Q_1' * A_1 * Q_2 = H_1,\n    Q_2' * A_2 * Q_3 = H_2,\n           ...\n    Q_p' * A_p * Q_1 = H_p.\n\nThe matrices A_1, A_2, ..., A_p are contained in the 3-dimensional array A.  The resulting H_1, H_2, ..., H_p and Q_1, Q_2, ..., Q_p overwrite  A_1, A_2, ..., A_p in A and the array tau.   \n\nSee the SLICOT documentation of MB03VD for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicMatrices.SLICOTtools.mb03vy!","page":"SLICOT Based Wrappers","title":"PeriodicMatrices.SLICOTtools.mb03vy!","text":" mb03vy!(n::Integer, p::Integer, ilo::Integer, ihi::Integer, A::Array{Float64, 3}, tau::AbstractMatrix{Float64}) -> info::Int64\n\nGenerate the real orthogonal matrices Q_1, Q_2, ..., Q_p, which are defined as the product of ihi-ilo elementary reflectors of order n, as returned in A_1, A_2, ..., A_p by mb03vd!:\n\n Q_j = H_j(ilo) H_j(ilo+1) . . . H_j(ihi-1).\n\nThe 3-dimensional arrays A and tau contains the information on the employed elementary reflectors. The resulting Q_1, Q_2, ..., Q_p overwrite A_1, A_2, ..., A_p. \n\nSee the SLICOT documentation of MB03VY for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicMatrices.SLICOTtools.mb03wd!","page":"SLICOT Based Wrappers","title":"PeriodicMatrices.SLICOTtools.mb03wd!","text":"mb03wd!(job::AbstractChar, compz::AbstractChar, n::Integer, p::Integer, \n        ilo::Integer, ihi::Integer, iloz::Integer, ihiz::Integer,  h::Array{Float64, 3}, z::Array{Float64, 3}, \n        wr::AbstractVector{Float64}, wi::AbstractVector{Float64}, ldwork::Integer) -> info::Int64\n\nCompute the Schur decomposition and the eigenvalues of a product of matrices, H = H_1H_2...*H_p, with H_1 an upper Hessenberg matrix and H_2, ..., H_p upper triangular matrices, without evaluating the product. Specifically, the matrices Z_i are computed, such that\n\n    `Z_1' * H_1 * Z_2 = T_1,`\n    `Z_2' * H_2 * Z_3 = T_2,`\n           `...`\n    `Z_p' * H_p * Z_1 = T_p,`\n\nwhere T_1 is in real Schur form, and T_2, ..., T_p are upper triangular.\n\nThe routine works primarily with the Hessenberg and triangular submatrices in rows and columns ILO to IHI, but optionally applies the transformations to all the rows and columns of the matrices H_i, i = 1,...,p. The transformations can be optionally accumulated.\n\nSee the SLICOT documentation of MB03WD for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicMatrices.SLICOTtools.mb03vw!","page":"SLICOT Based Wrappers","title":"PeriodicMatrices.SLICOTtools.mb03vw!","text":"mb03vw!(compq::AbstractChar, triu::AbstractChar, qind::AbstractVector{Int64}, k::Integer, n::Integer, h::Integer, \n        ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{Float64, 3}, q::Array{Float64, 3}, \n        liwork::Integer, ldwork::Integer) -> info::Int64\n        \nmb03vw!(compq::AbstractChar, triu::AbstractChar, qind::AbstractVector{Int64}, k::Integer, n::Integer, h::Integer, \n        ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{Float64, 3}, q::Array{Float64, 3}, \n        iwork::AbstractVector{Int64}, dwork::AbstractVector{Float64}) -> info::Int64\n\nReduce the generalized matrix product\n\n          s[1]           s[2]                 s[k]\n  A[:,:,1]     * A[:,:,2]     * ... * A[:,:,k]\n\nto upper Hessenberg-triangular form, where A is N-by-N-by-K and S is the signature array with values 1 or -1. The H-th matrix of A is reduced to upper Hessenberg form while the other matrices are triangularized. \n\nIf compq = 'U' or compq = 'I', then the orthogonal factors are computed and stored in the array Q so that for s[i] = 1,\n\n                T\n    Q[:,:,i](in)   A[:,:,i](in)   Q[:,:,mod(i,k)+1](in)\n                                                        T \n=   Q[:,:,i](out)  A[:,:,i](out)  Q[:,:,mod(i,k)+1](out),\n\nand for s[i] = -1,\n\n                         T\n    Q[:,:,mod(i,k)+1](in)   A[:,:,i](in)   Q[:,:,i](in)\n                                                        T \n=   Q[:,:,mod(i,k)+1](out)  A[:,:,i](out)  Q[:,:,i](out).\n\nA partial generation of the orthogonal factors can be realized via the array qind.\n\nIf triu = 'N' only matrices with negative signature are reduced to upper triangular form in the first stage of the algorithm.  If triu = 'A' all possible n-1 matrices with negative signature are reduced. \n\nSee the SLICOT documentation of MB03VW for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicMatrices.SLICOTtools.mb03bd!","page":"SLICOT Based Wrappers","title":"PeriodicMatrices.SLICOTtools.mb03bd!","text":"mb03bd!(job::AbstractChar, defl::AbstractChar, compq::AbstractChar, qind::AbstractVector{Int64}, k::Integer, n::Integer, h::Integer, \n        ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{Float64, 3}, q::Array{Float64, 3}, alphar::AbstractVector{Float64}, \n        alphai::AbstractVector{Float64}, beta::AbstractVector{Float64}, scal::AbstractVector{Int64}, \n        liwork::Integer, ldwork::Integer) -> (info::Int64, iwarn::Int64)\n\nmb03bd!(job::AbstractChar, defl::AbstractChar, compq::AbstractChar, qind::AbstractVector{Int64}, k::Integer, n::Integer, h::Integer, \n        ilo::Integer, ihi::Integer, s::AbstractVector{Int64}, a::Array{Float64, 3}, q::Array{Float64, 3}, alphar::AbstractVector{Float64}, \n        alphai::AbstractVector{Float64}, beta::AbstractVector{Float64}, scal::AbstractVector{Int64}, \n        iwork::AbstractVector{Int64}, dwork::AbstractVector{Float64}) -> (info::Int64, iwarn::Int64)\n\nFind the eigenvalues of the generalized matrix product\n\n          s[1]           s[2]                 s[k]\n  A[:,:,1]     * A[:,:,2]     * ... * A[:,:,k]\n\nwhere A[:,:,h] is upper Hessenberg and A[:,:,i], i <> h, is upper triangular, using a double-shift version of the periodic QZ method. In addition, A may be reduced to periodic Schur form: A[:,:,h] is upper quasi-triangular and all the other factors A[:,:,i] are upper triangular. Optionally, the 2-by-2 triangular matrices corresponding to 2-by-2 diagonal blocks in A[:,:,h] are so reduced that their product is a 2-by-2 diagonal matrix.\n\nIf compq = 'U' or compq = 'I', then the orthogonal factors are computed and stored in the array Q so that for s[i] = 1,\n\n                T\n    Q[:,:,i](in)   A[:,:,i](in)   Q[:,:,mod(i,k)+1](in)\n                                                        T \n=   Q[:,:,i](out)  A[:,:,i](out)  Q[:,:,mod(i,k)+1](out),\n\nand for s[i] = -1,\n\n                         T\n    Q[:,:,mod(i,k)+1](in)   A[:,:,i](in)   Q[:,:,i](in)\n                                                        T \n=   Q[:,:,mod(i,k)+1](out)  A[:,:,i](out)  Q[:,:,i](out).\n\nA partial generation of the orthogonal factors can be realized via the array qind.\n\nSee the SLICOT documentation of MB03BD for details.\n\n\n\n\n\n","category":"function"},{"location":"slicot.html#PeriodicMatrices.SLICOTtools.mb03kd!","page":"SLICOT Based Wrappers","title":"PeriodicMatrices.SLICOTtools.mb03kd!","text":"mb03kd!(compq::AbstractChar, strong::AbstractChar, k::Integer, nc::Integer, kschur::Integer, n::AbstractVector{Int64}, ni::AbstractVector{Int64}, \n        s::AbstractVector{Int64}, select::AbstractVector{BlasInt}, t::AbstractVector{Float64}, ldt::AbstractVector{Int64}, ixt::AbstractVector{Int64}, \n        q::AbstractVector{Float64}, ldq::AbstractVector{Int64}, ixq::AbstractVector{Int64}, tol::Float64, ldwork::Integer) -> (m::Int64, info::Int64)\n\nReorder the diagonal blocks of the formal matrix product\n\n T22_k^s[k] * T22_k-1^s[k-1] * ... * T22_1^s[1],                (1)\n\nof length k, in the generalized periodic Schur form,\n\n          [  T11_i  T12_i  T13_i  ]\n    T_i = [    0    T22_i  T23_i  ],    i = 1, ..., k,          (2)\n          [    0      0    T33_i  ]\n\nwhere\n\nthe submatrices T11_i are ni(i+1)-by-ni(i), if s[i] = 1, or ni(i)-by-ni(i+1), if s[i] = -1, and contain dimension-induced infinite eigenvalues,\nthe submatrices T22_i are nc-by-nc and contain core eigenvalues, which are generically neither zero nor infinite,\nthe submatrices T33_i contain dimension-induced zero eigenvalues,\n\nsuch that the m selected eigenvalues pointed to by the integer vector select end up in the leading part of the matrix sequence T22_i.\n\nGiven that n[i] = n[i+1] for all i where s[i] = -1, the T11_i are void and the first m columns of the updated orthogonal transformation matrix sequence Q_1, ..., Q_k span a periodic deflating subspace corresponding to the same eigenvalues.\n\nIf compq = 'U' or compq = 'I', then the orthogonal factors are computed and stored in the array Q so that for s[i] = 1,\n\n           T\n    Q_i(in)  T_i(in) Q_(mod(i,k)+1)(in)\n                                          T \n=   Q_i(out) T_i(out)  Q_(mod(i,k)+1)(out),\n\nand for s[i] = -1,\n\n                      T\n    Q_(mod(i,k)+1)(in)   T_i(in)   Q_i(in)\n                                           T \n=   Q_(mod(i,k)+1)(out)  T_i(out)  Q_i(out).\n\nSee the SLICOT documentation of MB03KD for details.\n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#Periodic-matrix-utilities","page":"Periodic Matrix Tools","title":"Periodic matrix utilities","text":"","category":"section"},{"location":"pmtools.html","page":"Periodic Matrix Tools","title":"Periodic Matrix Tools","text":"pseig   Characteristic multipliers of a periodic matrix.\npsceig   Characteristic exponents of a periodic matrix.\npseigsm   Characteristic multipliers of a periodic symbolic matrix.\npsceighr   Characteristic exponents of a periodic matrix in Harmonic Array representation.\npsceigfr   Characteristic exponents of a periodic matrix in Fourier Function Matrix representation.\npsceigsm   Characteristic exponents of a periodic matrix in symbolic representation.\nmonodromy  Monodromy matrix of a linear periodic time-varying system of ODE.\ntvstm  State transition matrix of a linear periodic time-varying system of ODE.\ntvmeval  Time response evaluation of a continuous-time periodic matrix. \nhreval  Evaluation of a harmonic array for a numerical or symbolic time value. \nhrchop  Removal of the negligible trailing terms of a harmonic representation. \nhrtrunc  Truncation of a harmonic representation.  \npmaverage  Evaluation of the time averaged matrix of a continuous-time periodic matrix. ","category":"page"},{"location":"pmtools.html","page":"Periodic Matrix Tools","title":"Periodic Matrix Tools","text":"pseig(at::PM, K::Int64; lifting, solver, reltol, abstol, dt) where {T, PM<:Union{HarmonicArray{:c, T}, PeriodicFunctionMatrix{:c, T}}}\npseig(A::PeriodicArray{:d, T}; fast) where T\npseig(A::PeriodicMatrix{:d, T}, k::Int64; fast) where T\npsceig\npseigsm\npsceighr\nPeriodicMatrices.psceigfr\npsceigsm\nmonodromy\ntvstm\ntvmeval\nhreval\nhrchop\nhrtrunc\npmaverage","category":"page"},{"location":"pmtools.html#PeriodicMatrices.pseig-Union{Tuple{PM}, Tuple{T}, Tuple{PM, Int64}} where {T, PM<:Union{HarmonicArray{:c, T}, PeriodicFunctionMatrix{:c, T}}}","page":"Periodic Matrix Tools","title":"PeriodicMatrices.pseig","text":" pseig(A, K = 1; lifting = false, solver, reltol, abstol, dt) -> cm\n\nCompute the characteristic multipliers of a continuous-time periodic matrix. \n\nFor the given square periodic matrix A(t) of period T,  the characteristic multipliers cm are the eigenvalues of  the monodromy matrix Ψ = Φ(T,0), where Φ(t,τ) is the state transition matrix satisfying the homogeneous linear ODE \n\ndΦ(t,τ)/dt = A(t)Φ(t,τ),  Φ(τ,τ) = I.\n\nIf lifting = false, Ψ is computed as a product of K state transition matrices  Ψ = Ψ_K*...*Ψ_1 (see monodromy with the associated keyword arguments).  The eigenvalues are computed using the periodic Schur decomposition method of [1]. A may be given as a PeriodicFunctionMatrix, a HarmonicArray, a PeriodicSymbolicMatrix or a  FourierFunctionMatrix. \n\nIf lifting = true, Ψ is (implicitly) expressed as Ψ = inv(N)*M, where M-λN is a regular pencil with N invertible and   the eigenvalues of M-λN are the same as those of the matrix product Ψ := Ψ_K*...*Ψ_1.  An efficient version of the structure exploiting fast reduction method of [2] is employed,  which embeds the determination of transition matrices into the reduction algorithm.  This option may occasionally lead to inaccurate results for large values of K. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"method"},{"location":"pmtools.html#PeriodicMatrices.pseig-Union{Tuple{PeriodicArray{:d, T}}, Tuple{T}} where T","page":"Periodic Matrix Tools","title":"PeriodicMatrices.pseig","text":" cm = pseig(A::PeriodicArray; fast = false)\n\nCompute the characteristic multipliers of a discrete-time periodic matrix A(t).  A is given as a PeriodicArray. The characteristic multipliers are computed   as the eigenvalues of the reverse product of component matrices,  without evaluating the product.  If fast = false (default) then the eigenvalues are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed. This later option may occasionally lead to inaccurate results for large number of matrices. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"method"},{"location":"pmtools.html#PeriodicMatrices.pseig-Union{Tuple{T}, Tuple{PeriodicMatrix{:d, T}, Int64}} where T","page":"Periodic Matrix Tools","title":"PeriodicMatrices.pseig","text":"cm = pseig(A::PeriodicMatrix[, k = 1]; fast = false) \n\nCompute the characteristic multipliers of a discrete-time periodic matrix A(t).  A is given as a PeriodicMatrix. The characteristic multipliers are computed   as the eigenvalues of the reverse product of component matrices,  without evaluating the product.  The argument k specifies the starting index of component matrices (default: k = 1).  If fast = false (default) then the eigenvalues are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed.  This later option may occasionally lead to inaccurate results for large number of matrices. \n\nNote: The first nmin components of cm contains the core characteristic multipliers, where nmin is the minimum row dimensions of component matrices,  while the last ncur-nmin components of cm are zero,  where ncur is the column dimension of the k-th component matrix. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"method"},{"location":"pmtools.html#PeriodicMatrices.psceig","page":"Periodic Matrix Tools","title":"PeriodicMatrices.psceig","text":" psceig(A[, K = 1]; lifting = false, solver, reltol, abstol, dt) -> ce\n\nCompute the characteristic exponents of a continuous-time periodic matrix.\n\nFor a given square continuous-time periodic matrix A(t) of period T,  the characteristic exponents ce are computed as log.(ev)/T,  where  ev are the characteristic multipliers (i.e., the eigenvalues of the monodromy matrix of A(t)).   For available options see pseig(::PeriodicFunctionMatrix).  A may be given as a PeriodicFunctionMatrix, a HarmonicArray, a PeriodicSymbolicMatrix or a  FourierFunctionMatrix.  For a given square discrete-time periodic matrix A(t) of discrete period N,   the characteristic exponents ce are computed as ev.^-N. \n\n\n\n\n\npsceig(A[, k]; fast = false) -> ce\n\nCompute the characteristic exponents of a cyclic matrix product of p matrices.\n\nCompute the characteristic exponents of a discrete-time periodic matrix A(t). The characteristic exponents are computed from the characteristic multipliers as determined by calling the function pseig(::PeriodicMatrix).  If fast = false (default) then the characteristic multipliers are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed. This later option may occasionally lead to inaccurate results for large number of matrices. \n\nThe argument k specifies the starting index of the component matrices (default: k = 1). \n\nNote: The first nmin components of ce contains the core characteristic exponents, where nmin is the minimum row dimensions of the component matrices,  while the last components of ce are zero. \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.pseigsm","page":"Periodic Matrix Tools","title":"PeriodicMatrices.pseigsm","text":" pseigsm(PeriodicSymbolicMatrix[, K = 1]; lifting = false, solver, reltol, abstol, dt) -> ev\n\nCompute the characteristic multipliers of a continuous-time periodic symbolic matrix. \n\nFor the given square periodic matrix A(t) of period T,  the characteristic multipliers ev are the eigenvalues of  the monodromy matrix Ψ = Φ(T,0), where Φ(t,τ) is the state transition matrix satisfying the homogeneous linear ODE \n\ndΦ(t,τ)/dt = A(t)Φ(t,τ),  Φ(τ,τ) = I.\n\nIf lifting = false, Ψ is computed as a product of K state transition matrices  Ψ = Ψ_K*...*Ψ_1 (see monodromy with the associated keyword arguments).  The eigenvalues are computed using the periodic Schur decomposition method of [1].\n\nIf lifting = true, Ψ is (implicitly) expressed as Ψ = inv(N)*M, where M-λN is a regular pencil with N invertible and   the eigenvalues of M-λN are the same as those of the matrix product Ψ := Ψ_K*...*Ψ_1.  An efficient version of the structure exploiting fast reduction method of [2] is employed,  which embeds the determination of transition matrices into the reduction algorithm.  This option may occasionally lead to inaccurate results for large values of K.  A has the type PeriodicSymbolicMatrix.\n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.psceighr","page":"Periodic Matrix Tools","title":"PeriodicMatrices.psceighr","text":"psceighr(Ahr::HarmonicArray[, N]; P, nperiod, shift, atol) -> ce\n\nCompute the characteristic exponents of a continuous-time periodic matrix in Harmonic Array representation. \n\nFor a given square continuous-time periodic function matrix Ahr(t) of period T  in a  Harmonic Array representation,  the characteristic exponents ce are computed as the eigenvalues of a truncated harmonic state operator A(N)-E(N) lying in the  fundamental strip -ω/2 <  Im(λ) ≤ ω/2, where ω = 2π/T. If Ahr(t) has the harmonic components A_0, A_1, ..., A_p, then  for N ≥ p, P = 1 and nperiod = 1, the matrices A(N) and E(N) are built as\n\n       ( A_0  A_{-1} …  A_{-p}        0    )           ( -im*ϕ_{-N}I                                 0        )\n       ( A_1   A_0             ⋱           )           (     ⋮       ⋱                                        )\n       (  ⋮         ⋱            ⋱         )           (               -im*ϕ_{-1}*I                           )\nA(N) = ( A_p             ⋱          A_{-p} ) , E(N) =  (                           -im*ϕ_{0}*I                )\n       (        ⋱           ⋱         ⋮    )           (     ⋮                                  ⋱              )\n       (  0        A_p      …         A_0  )           (     0                                   -im*ϕ_{N}I   )\n\nwith ϕ_{i} := shift+i*ω. If N < p, then a truncated full block Toeplitz matrix A(N) is built using the first N harmonic components.  The default value used for N is N = max(10,p-1). \n\nGenerally, for given P ≥ 1 and  nperiod ≥ 1, the block Toeplitz matrix A(N) (and also E(N)) is constructed with (2N*np+1)×(2N*np+1) blocks, with np = P*nperiod, such that each A_i is preceeded in its column by np-1 zero blocks,  each A_{-i} is preceeded in its row by np-1 zero blocks and all diagonal blocks are equal toA_0.  \n\nThe keyword argument atol (default: atol = 1.e-10) is a tolerance on the magnitude of the trailing components of the  associated eigenvectors used to validate their asymptotic (exponential) decay.  Only eigenvalues satisfying this check are returned in ce. \n\nReferences\n\n[1] J. Zhou, T. Hagiwara, and M. Araki.      Spectral characteristics and eigenvalues computation of the harmonic state operators in continuous-time periodic systems.      Systems and Control Letters, 53:141–155, 2004.\n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.psceigfr","page":"Periodic Matrix Tools","title":"PeriodicMatrices.psceigfr","text":"psceigfr(A::FourierFunctionMatrix[, N]; P, atol) -> ce\n\nCompute the characteristic exponents of a continuous-time periodic matrix in Fourier Function Matrix representation. \n\nFor a given square continuous-time periodic function matrix A(t) of period T  in a  Fourier Function Matrix representation,  the characteristic exponents ce are computed as the eigenvalues of the state operator A(t)-D*I lying in the  fundamental strip -ω/2 <  Im(λ) ≤ ω/2, where ω = 2π/T. A finite dimensional truncated matrix of order n*(2*N*P+1)  is built to approximate A(t)-D*I, where n is the order of A(t),  N is the number of selected harmonic components in the Fourier representation and P is the period multiplication number (default: P = 1). The default value used for N is N = max(10,p-1), where p the number of harmonics terms of A(t) (see FourierFunctionMatrix). \n\nThe keyword argument atol (default: atol = 1.e-10) is a tolerance on the magnitude of the trailing components of the  associated eigenvectors used to validate their asymptotic (exponential) decay. Only eigenvalues satisfying this check are returned in ce. \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.psceigsm","page":"Periodic Matrix Tools","title":"PeriodicMatrices.psceigsm","text":" psceigsm(A::PeriodicSymbolicMatrix[, K = 1]; lifting = false, solver, reltol, abstol, dt) -> ce\n\nCompute the characteristic exponents of a periodic symbolic matrix.\n\nFor a given square continuous-time periodic function matrix A(t) of period T,  the characteristic exponents ce are computed as log.(ev)/T,  where  ev are the characteristic multipliers (i.e., the eigenvalues of the monodromy matrix of A(t)).   For available options see pseig(::PeriodicFunctionMatrix). \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.monodromy","page":"Periodic Matrix Tools","title":"PeriodicMatrices.monodromy","text":" monodromy(A[, K = 1]; solver, reltol, abstol, dt) -> Ψ::PeriodicArray\n\nCompute the monodromy matrix for a linear ODE with periodic time-varying coefficients. \n\nFor the given square periodic matrix A(t) of period T and subperiod T′ = T/k, where  k is the number of subperiods,   the monodromy matrix Ψ = Φ(T′,0) is computed, where Φ(t,τ) is the state transition matrix satisfying the homogeneous linear ODE \n\ndΦ(t,τ)/dt = A(t)Φ(t,τ),  Φ(τ,τ) = I.\n\nA may be given as a PeriodicFunctionMatrix, a HarmonicArray, a PeriodicSymbolicMatrix or a  FourierFunctionMatrix. \n\nIf K > 1, then Ψ = Φ(T′,0) is determined as a product of K matrices  Ψ = Ψ_K*...*Ψ_1, where for Δ := T′/K, Ψ_i = Φ(iΔ,(i-1)Δ) is the  state transition matrix on the time interval [(i-1)Δ,iΔ]. \n\nThe state transition matrices Φ(iΔ,(i-1)Δ) are computed by integrating numerically the above homogeneous linear ODE.   The ODE solver to be employed can be  specified using the keyword argument solver, together with the required relative accuracy reltol (default: reltol = 1.e-3),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt = min(Δ, Δ*K′/100)) (see tvstm).  For large values of K, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\n\n\n\n\n monodromy(A::PeriodicTimeSeriesMatrix) -> Ψ::PeriodicArray\n\nCompute the monodromy matrix for a continuous-time time series matrix. \n\nFor the given square periodic matrix A(t) of period T and subperiod T′ = T/k, where  k is the number of subperiods,   the monodromy matrix Ψ = Φ(T′,0) is computed, where Φ(t,τ) is the state transition matrix satisfying the homogeneous linear ODE \n\ndΦ(t,τ)/dt = A(t)Φ(t,τ),  Φ(τ,τ) = I.\n\nA is a PeriodicTimeSeriesMatrix with K component matices and the resulting monodromy matrix Ψ  is stored as a discrete-time periodic array with K component matrices, of period T and k subperiods. \n\nΨ = Φ(T′,0) is determined as a product of K matrices  Ψ = Ψ_K*...*Ψ_1, where for Δ := T′/K, Ψ_i = Φ(iΔ,(i-1)Δ) is the  state transition matrix on the time interval [(i-1)Δ,iΔ].  Each state transition matrix is computed as a matrix exponential  Φ(iΔ,(i-1)Δ) = exp(A[i]*Δ),  where A[i] is the i-th component matrix of the time series representation.   For large values of K, parallel computation of factors can be alternatively performed  by starting Julia with several execution threads.  The number of execution threads is controlled either by using the -t/--threads command line argument  or by using the JULIA_NUM_THREADS environment variable.  \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.tvstm","page":"Periodic Matrix Tools","title":"PeriodicMatrices.tvstm","text":" tvstm(A, tf, t0; solver, reltol, abstol, dt) -> Φ\n\nCompute the state transition matrix for a linear ODE with periodic time-varying coefficients.  For the given square periodic continuous-time matrix A(t), initial time t0 and  final time tf, the state transition matrix Φ(tf,t0) is computed by integrating numerically the homogeneous linear ODE \n\n  dΦ(t,t0)/dt = A(t)Φ(t,t0),  Φ(t0,t0) = I\n\non the time interval [t0,tf].   A may be given as a PeriodicFunctionMatrix, a HarmonicArray, a PeriodicSymbolicMatrix or a  FourierFunctionMatrix. \n\nThe ODE solver to be employed can be  specified using the keyword argument solver (see below), together with the required relative accuracy reltol (default: reltol = 1.e-3),  absolute accuracy abstol (default: abstol = 1.e-7) and/or  the fixed step length dt (default: dt = tf-t0).  Depending on the desired relative accuracy reltol,  lower order solvers are employed for reltol >= 1.e-4,  which are generally very efficient, but less accurate. If reltol < 1.e-4, higher order solvers are employed able to cope with high accuracy demands. \n\nThe following solvers from the OrdinaryDiffEq.jl package can be selected:\n\nsolver = \"non-stiff\" - use a solver for non-stiff problems (Tsit5() or Vern9());\n\nsolver = \"stiff\" - use a solver for stiff problems (Rodas4() or KenCarp58());\n\nsolver = \"linear\" - use a special solver for linear ODEs (MagnusGL6()) with fixed time step dt;\n\nsolver = \"symplectic\" - use a symplectic Hamiltonian structure preserving solver (IRKGL16());\n\nsolver = \"\" - use the default solver, which automatically detects stiff problems (AutoTsit5(Rosenbrock23()) or AutoVern9(Rodas5())). \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.tvmeval","page":"Periodic Matrix Tools","title":"PeriodicMatrices.tvmeval","text":" tvmeval(At::PeriodicTimeSeriesMatrix, t; method = \"linear\") -> A::Vector{Matrix}\n\nEvaluate the time response of a periodic time series matrix.\n\nFor the periodic time series matrix At and the vector of time values t,  an interpolation/extrapolation based approximation   A[i] is evaluated for each time value t[i]. The keyword parameter method specifies the interpolation/extrapolation method to be used for periodic data.  The following interpolation methods from the Interpolations.jl  package can be selected: \n\nmethod = \"constant\" - use periodic B-splines of degree 0; \n\nmethod = \"linear\" - use periodic B-splines of degree 1 (periodic linear interpolation) (default);\n\nmethod = \"quadratic\" - use periodic B-splines of degree 2 (periodic quadratic interpolation); \n\nmethod = \"cubic\" - use periodic B-splines of degree 3 (periodic cubic interpolation).\n\n\n\n\n\n tvmeval(Ahr::HarmonicArray, t; ntrunc, exact = true) -> A::Vector{Matrix}\n\nEvaluate the time response of a harmonic array.\n\nFor the harmonic array Ahr representing representing a continuous-time  time periodic matrix A(t) and the vector of time values t,  A[i] = A(t[i]) is computed for each time value t[i].  If exact = true (default) an exact evaluation is computed, while for exact = false,  a linear interpolation based approximation is computed  (potentially more accurate in intersample points). The keyword argument ntrunc specifies the number of harmonics to be used for evaluation  (default: maximum possible number of harmonics). \n\n\n\n\n\n tvmeval(A, t) -> Aval::Vector{Matrix}\n\nEvaluate the time response of a periodic matrix.\n\nFor the periodic matrix A(t) and the vector of time values t,  the vector Aval of time values is computed such that  Aval[i] = A(t[i]) for each time value t[i]. \n\n\n\n\n\n tvmeval(Asym::PeriodicSymbolicMatrix, t) -> A::Vector{Matrix}\n\nEvaluate the time response of a periodic symbolic matrix.\n\nFor the periodic symbolic matrix Asym representing a time periodic matrix A(t) and the vector of time values t,  A[i] = A(t[i]) is evaluated for each time value t[i]. \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.hreval","page":"Periodic Matrix Tools","title":"PeriodicMatrices.hreval","text":" hreval(Ahr::HarmonicArray, t; ntrunc, exact = true) -> A::Matrix\n\nEvaluate the harmonic array Ahr representing a continuous-time  time periodic matrix A(t) for a time value t.  For a real value t, if exact = true (default) an exact evaluation is computed, while for exact = false,  a linear interpolation based approximation is computed (potentially more accurate in intersample points). The keyword argument ntrunc specifies the number of harmonics to be used for the evaluation  (default: maximum possible number). \n\n\n\n\n\n hreval(Ahr::HarmonicArray, t; ntrunc, exact = true) -> A::Matrix\n\nEvaluate the harmonic array Ahr representing a continuous-time  time periodic matrix A(t) for a symbolic time value t.  A symbolic evaluation of A(t) is performed (see also hr2psm) The keyword argument ntrunc specifies the number of harmonics to be used for the evaluation  (default: maximum possible number). \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.hrchop","page":"Periodic Matrix Tools","title":"PeriodicMatrices.hrchop","text":" hrchop(Ahr::HarmonicArray; tol) -> Ahrtrunc::HarmonicArray\n\nRemove the trailing terms of a harmonic representation by deleting those whose norms are below a certain tolerance. \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.hrtrunc","page":"Periodic Matrix Tools","title":"PeriodicMatrices.hrtrunc","text":" hrtrunc(Ahr::HarmonicArray, n) -> Ahrtrunc::HarmonicArray\n\nTruncate a harmonic representation by deleting the trailing terms whose indices exceed certain number n of harmonics. \n\n\n\n\n\n","category":"function"},{"location":"pmtools.html#PeriodicMatrices.pmaverage","page":"Periodic Matrix Tools","title":"PeriodicMatrices.pmaverage","text":"pmaverage(A; rtol = sqrt(eps())) -> Am\n\nCompute for the continuous-time periodic matrix A(t)  the corresponding time averaged matrix Am over one period.  The Gauss-Konrod quadratue method is employed for numerical integration using a relative accuracy tolerance specified by rtol. \n\n\n\n\n\npmaverage(A::PeriodicSymbolicMatrix) -> Am\n\nCompute for the continuous-time periodic matrix A(t)  the corresponding time averaged matrix Am over one period.  \n\n\n\n\n\n","category":"function"},{"location":"pmtypes.html#Constructors-for-periodic-matrices","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"","category":"section"},{"location":"pmtypes.html#Discrete-time-periodic-matrices","page":"Constructors for periodic matrices","title":"Discrete-time periodic matrices","text":"","category":"section"},{"location":"pmtypes.html","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"PeriodicMatrix   Discrete-time periodic matrix representation.\nPeriodicArray    Discrete-time periodic array representation.\nSwitchingPeriodicMatrix Discrete-time switching periodic matrix representation.\nSwitchingPeriodicArray Discrete-time switching periodic array representation.","category":"page"},{"location":"pmtypes.html","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"PeriodicMatrix\nSwitchingPeriodicMatrix\nsize(A::PeriodicMatrix)\nlength(A::PeriodicMatrix)\neltype(A::PeriodicMatrix)\ngetindex(A::PeriodicMatrix, ind::Int64)\ngetindex(A::PeriodicMatrix, inds...)\nlastindex(A::PeriodicMatrix)\nlastindex(A::PeriodicMatrix, dim::Int64)\nPeriodicArray\nSwitchingPeriodicArray\nsize(A::PeriodicArray)\nlength(A::PeriodicArray)\neltype(A::PeriodicArray) \ngetindex(A::PM, ind::Int64) where PM<:PeriodicArray\ngetindex(A::PeriodicArray, inds...)\nlastindex(A::PeriodicArray)\nlastindex(A::PeriodicArray, dim::Int64)","category":"page"},{"location":"pmtypes.html#PeriodicMatrices.PeriodicMatrix","page":"Constructors for periodic matrices","title":"PeriodicMatrices.PeriodicMatrix","text":"PeriodicMatrix(M, T; nperiod = k) -> A::PeriodicMatrix\n\nDiscrete-time periodic matrix representation. \n\nThe discrete-time periodic matrix object A is built from a  p-vector M of real matrices, the associated time period T and  the number of subperiods specified via the keyword argument nperiod = k. \n\nM contains the cyclic component matrices M[i], i = 1,..., p,  where M[i] represents the value M(Δ(i-1)) of a time periodic matrix M(t) of period T/k, with Δ := T/(k*p), the associated sample time.  It is assumed that M[i] := M[mod(i-1,p)+1] for arbitrary i.  All component matrices are allowed to have arbitrary (time-varying) dimensions. The component matrices M, the period T, the number of subperiods k, the discrete period p  and the sample time Δ can be accessed via A.M, A.period, A.nperiod, A.dperiod and A.Ts, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#PeriodicMatrices.SwitchingPeriodicMatrix","page":"Constructors for periodic matrices","title":"PeriodicMatrices.SwitchingPeriodicMatrix","text":"SwitchingPeriodicMatrix(M, ns, T; nperiod = k) -> A::SwitchingPeriodicMatrix\n\nDiscrete-time switching periodic matrix representation.\n\nThe discrete-time switching periodic matrix object A is built from a  p-vector M of real matrices, a p-vector ns of increasing positive integers representing the discrete switching moments,  the associated time period T and  the number of subperiods specified via the keyword argument nperiod = k. \n\nM contains the component matrices M[i], i = 1,..., p, which defines  a sequence of N := ns[p] of matrices S[1], ..., S[N],  such that S[j] = M[i] for j ∈ [ns[i-1]+1, ..., ns[i]] with ns[0] := 0. S[j] is the j-th value A(Δ(j-1)) of a time periodic matrix A(t) of subperiod T′ := T/k, with Δ := T′/N, the associated sample time.  All component matrices are allowed to have arbitrary (time-varying) dimensions. The component matrices M, the integer vector ns, the period T,  the number of subperiods k, the discrete period N  and the sample time Δ can be accessed via A.M, A.ns, A.period, A.nperiod, A.dperiod and A.Ts, respectively. \n\nThe j-th time value A(Δ(j-1)) can be determined as A[j].  It is assumed that A[j] := A[mod(j-1,N)+1] for arbitrary j. \n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#Base.size-Tuple{PeriodicMatrix}","page":"Constructors for periodic matrices","title":"Base.size","text":"size(A::PeriodicMatrix)\nsize(A::SwitchingPeriodicMatrix)\nsize(A::PeriodicMatrix[, dim])\nsize(A::SwitchingPeriodicMatrix[, dim])\n\nReturn a tuple of two vectors containing the dimensions of the components of the discrete-time periodic matrix A.  Optionally you can specify a dimension dim to just get the vector of lengths of that dimension.\n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.length-Tuple{PeriodicMatrix}","page":"Constructors for periodic matrices","title":"Base.length","text":"length(A::PeriodicMatrix)\nlength(A::SwitchingPeriodicMatrix)\n\nReturn the number of component matrices (also called the discrete period) of the discrete-time periodic matrix A.  \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.eltype-Tuple{PeriodicMatrix}","page":"Constructors for periodic matrices","title":"Base.eltype","text":"eltype(A::PeriodicMatrix)\neltype(A::SwitchingPeriodicMatrix)\n\nDetermine the type of the elements of component matrices of the discrete-time periodic matrix A. \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.getindex-Tuple{PeriodicMatrix, Int64}","page":"Constructors for periodic matrices","title":"Base.getindex","text":"getindex(A::PeriodicMatrix, i)\ngetindex(A::SwitchingPeriodicMatrix, i)\n\nReturn the i-th component matrix of the discrete-time periodic matrix A. Equivalent to the syntax A[i]. \n\n\n\n\n\ngetindex(A::PeriodicMatrix, ind1, ind2)\ngetindex(A::SwitchingPeriodicMatrix, ind1, ind2)\n\nReturn the discrete-time periodic matrix built from the selected ranges [ind1,ind2] of elements of the component matrices.  ind1 and ind2 may be integers, integer ranges or colons.  \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.getindex-Tuple{PeriodicMatrix, Vararg{Any}}","page":"Constructors for periodic matrices","title":"Base.getindex","text":"getindex(A::PeriodicMatrix, ind1, ind2)\ngetindex(A::SwitchingPeriodicMatrix, ind1, ind2)\n\nReturn the discrete-time periodic matrix built from the selected ranges [ind1,ind2] of elements of the component matrices.  ind1 and ind2 may be integers, integer ranges or colons.  \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.lastindex-Tuple{PeriodicMatrix}","page":"Constructors for periodic matrices","title":"Base.lastindex","text":"lastindex(A::PeriodicMatrix)\nlastindex(A::SwitchingPeriodicMatrix)\n\nReturn the last index of the component matrices of the discrete-time periodic matrix A.  The syntax A[end] is equivalent to A[lastindex(A)]. \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.lastindex-Tuple{PeriodicMatrix, Int64}","page":"Constructors for periodic matrices","title":"Base.lastindex","text":"lastindex(A::PeriodicMatrix,dim)\nlastindex(A::SwitchingPeriodicMatrix,dim)\n\nReturn the vector of last indices along dimension dim of the component matrices of the discrete-time periodic matrix A. \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#PeriodicMatrices.PeriodicArray","page":"Constructors for periodic matrices","title":"PeriodicMatrices.PeriodicArray","text":"PeriodicArray(M, T; nperiod = k) -> A::PeriodicArray\n\nDiscrete-time periodic array representation.\n\nThe discrete-time periodic array object A is built from a m×n×p real array M, the associated time period T and the number of subperiods specified via  the keyword argument nperiod = k.  M contains the cyclic component matrices M[:,:,i], i = 1,..., p,  where M[:,:,i] represents the value M(Δ(i-1)) of a time periodic matrix M(t) of period T/k, with Δ := T/(kp), the associated sample time.  It is assumed that  M[:,:,k] := M[:,:,mod(k-1,p)+1] for arbitrary k.  The component matrices M, the period T, the number of subperiods k, the discrete period p  and the sample time Δ can be accessed via A.M, A.period, A.nperiod, A.dperiod and A.Ts, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#PeriodicMatrices.SwitchingPeriodicArray","page":"Constructors for periodic matrices","title":"PeriodicMatrices.SwitchingPeriodicArray","text":"SwitchingPeriodicArray(M, ns, T; nperiod = k) -> A::SwitchingPeriodicArray\n\nDiscrete-time switching periodic array representation.\n\nThe discrete-time switching periodic array object A is built from a m×n×p real array M, a p-vector ns of increasing positive integers representing the discrete switching moments, the associated time period T and  the number of subperiods specified via the keyword argument nperiod = k. \n\nM contains the cyclic component matrices M[:,:,i], i = 1,..., p, which defines  a sequence of N := ns[p] of matrices S[1], ..., S[N],  such that S[j] =M[:,:,i]forj ∈ [ns[i-1]+1, ..., ns[i]]withns[0] := 0.S[j]is thej-th valueA(Δ(j-1))of a time periodic matrixA(t)of subperiodT′ := T/k, withΔ := T′/N, the associated sample time.  The component matricesM, the integer vectorns, the periodT,  the number of subperiodsk, the discrete periodNand the sample timeΔcan be accessed viaA.M,A.ns,A.period,A.nperiod,A.dperiodandA.Ts`, respectively. \n\nThe j-th time value A(Δ(j-1)) can be determined as A[j].  It is assumed that A[j] := A[mod(j-1,N)+1] for arbitrary j. \n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#Base.size-Tuple{PeriodicArray}","page":"Constructors for periodic matrices","title":"Base.size","text":"size(A::PeriodicArray)\nsize(A::SwitchingPeriodicArray)\nsize(A::PeriodicArray[, dim])\nsize(A::SwitchingPeriodicArray[, dim])\n\nReturn a tuple of two integers containing the common row and column dimensions of the components of the discrete-time periodic matrix A.  Optionally you can specify a dimension dim to just get length of that dimension.\n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.length-Tuple{PeriodicArray}","page":"Constructors for periodic matrices","title":"Base.length","text":"length(A::PeriodicArray)\nlength(A::SwitchingPeriodicArray)\n\nReturn the number of component matrices (also called the discrete period) of the discrete-time periodic matrix A.  \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.eltype-Tuple{PeriodicArray}","page":"Constructors for periodic matrices","title":"Base.eltype","text":"eltype(A::PeriodicArray)\neltype(A::SwitchingPeriodicArray)\n\nDetermine the type of the elements of component matrices of the discrete-time periodic matrix A. \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.getindex-Union{Tuple{PM}, Tuple{PM, Int64}} where PM<:PeriodicArray","page":"Constructors for periodic matrices","title":"Base.getindex","text":"getindex(A::PeriodicArray, i)\ngetindex(A::SwitchingPeriodicArray, i)\n\nReturn the i-th component matrix of the discrete-time periodic matrix A. Equivalent to the syntax A[i]. \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.getindex-Tuple{PeriodicArray, Vararg{Any}}","page":"Constructors for periodic matrices","title":"Base.getindex","text":"getindex(A::PeriodicArray, ind1, ind2)\ngetindex(A::SwitchingPeriodicArray, ind1, ind2)\n\nReturn the discrete-time periodic matrix built from the selected ranges [ind1,ind2] of elements of the component matrices.  ind1 and ind2 may be integers, integer ranges or colons.  \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.lastindex-Tuple{PeriodicArray}","page":"Constructors for periodic matrices","title":"Base.lastindex","text":"lastindex(A::PeriodicArray)\nlastindex(A::SwitchingPeriodicArray)\n\nReturn the last index of the component matrices of the discrete-time periodic matrix A.  The syntax A[end] is equivalent to A[lastindex(A)]. \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.lastindex-Tuple{PeriodicArray, Int64}","page":"Constructors for periodic matrices","title":"Base.lastindex","text":"lastindex(A::PeriodicArray,dim)\nlastindex(A::SwitchingPeriodicArray,dim)\n\nReturn the last index along dimension dim of the component matrices of the discrete-time periodic matrix A. \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Continuous-time-periodic-matrices","page":"Constructors for periodic matrices","title":"Continuous-time periodic matrices","text":"","category":"section"},{"location":"pmtypes.html","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"PeriodicFunctionMatrix  Continuous-time periodic function matrix representation.\nPeriodicSymbolicMatrix   Continuous-time periodic symbolic matrix representation.\nPeriodicTimeSeriesMatrix   Continuous-time periodic time series matrix representation.\nHarmonicArray   Continuous-time harmonic array representation.\nFourierFunctionMatrix   Continuous-time Fourier functin matrix representation.\nPeriodicSwitchingMatrix Continuous-time switching periodic matrix representation.","category":"page"},{"location":"pmtypes.html","page":"Constructors for periodic matrices","title":"Constructors for periodic matrices","text":"PeriodicFunctionMatrix\nPeriodicSymbolicMatrix\nPeriodicTimeSeriesMatrix\nHarmonicArray\nHarmonicArray(A0::MT, Acos::Union{Nothing, Vector{MT}}, Asin::Union{Nothing, Vector{MT}}, period::Real) where {T<:Real, MT<:VecOrMat{T}} \nFourierFunctionMatrix\nPeriodicSwitchingMatrix\nsize(A::PeriodicFunctionMatrix)\neltype(A::PeriodicFunctionMatrix) \ngetindex(A::PeriodicFunctionMatrix, inds...)\nlastindex(A::PeriodicFunctionMatrix, dim::Int64)","category":"page"},{"location":"pmtypes.html#PeriodicMatrices.PeriodicFunctionMatrix","page":"Constructors for periodic matrices","title":"PeriodicMatrices.PeriodicFunctionMatrix","text":"PeriodicFunctionMatrix(f, T; nperiod = k) -> A::PeriodicFunctionMatrix\n\nContinuous-time periodic function matrix representation.\n\nThe continuous-time periodic real matrix function f(t) of real time variable t,  the associated time period T and the associated number of subperiods specified via the keyword argument nperiod = k.  It is assumed that  f(t) = f(t+T/k) for any real time value t. The function f(t), the period T, the row and column dimensions  of f(t), the number of subperiods k can be accessed via A.f, A.period,  the tuple A.dims and A.nperiod, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#PeriodicMatrices.PeriodicSymbolicMatrix","page":"Constructors for periodic matrices","title":"PeriodicMatrices.PeriodicSymbolicMatrix","text":"PeriodicSymbolicMatrix(F, T; nperiod = k) -> A::PeriodicSymbolicMatrix\n\nContinuous-time periodic symbolic matrix representation.\n\nThe continuous-time periodic symbolic matrix object A is built from F, a  symbolic real matrix or vector of symbolic variable t,  the associated time period T and the associated number of subperiods specified via the keyword argument nperiod = k.  It is assumed that  F(t) = F(t+T/k) for any real time value t. The symbolic matrix F, the period T and the number of subperiods k  can be accessed via A.F, A.period and A.nperiod, respectively.\n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#PeriodicMatrices.PeriodicTimeSeriesMatrix","page":"Constructors for periodic matrices","title":"PeriodicMatrices.PeriodicTimeSeriesMatrix","text":"PeriodicTimeSeriesMatrix(At, T; nperiod = k) -> A::PeriodicTimeSeriesMatrix\n\nContinuous-time periodic time series matrix representation.\n\nThe continuous-time periodic time series matrix object A of period T is built from a  p-vector At of real matrices and the associated subperiod T′ = T/k, where k ≥ 1 is the number of subperiods (default: k = 1).  At contains the cyclic component matrices At[i], i = 1,..., p,  where At[i] represents the value A(Δ*(i-1)) of a time periodic matrix A(t) of period T′, with Δ := T′/p, the associated sampling time. It is assumed that At[i] := At[mod(i-1,p)+1] for arbitrary i.  All component matrices must have the same dimensions. The component matrices At, the period T and the number of subperiods k can be accessed via A.values, A.period, and A.nperiod, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#PeriodicMatrices.HarmonicArray","page":"Constructors for periodic matrices","title":"PeriodicMatrices.HarmonicArray","text":" HarmonicArray(Ahr, T; nperiod = k) -> A::HarmonicArray\n\nContinuous-time harmonic array representation.\n\nThe harmonic array object A of period T is built using the harmonic representation of a periodic matrix Ahr(t) of subperiod T′ = T/k in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T′)+As_i*sin(i*2*π*t/T′) ) ,\n                i=1\n\nwhere k ≥ 1 is the number of subperiods (default: k = 1).                    The m×n×(p+1) complex array Ahr contains the harmonic components as follows: Ahr[:,:,1] contains the constant term A_0 (the mean value) and the real and imaginary parts of Ahr[:,:,i+1]   for i = 1, ..., p contain the coefficient matrices Ac_i and As_i, respectively.  The complex matrix Ahr containing the harmonic components, the period T and the  number of subperiods k can be accessed via A.values, A.period and A.nperiod, respectively.\n\n\n\n\n\n HarmonicArray(A0, Ac, As, T) -> A::HarmonicArray\n\nConstruct a harmonic array representation from the harmonic components.\n\nThe harmonic array object A is built for  the harmonic representation Ahr(t) of a periodic matrix of period T in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T)+As_i*sin(i*2*π*t/T) ) ,\n                i=1\n\nwhere the constant term A_0 is contained in the real matrix A0, and Ac and As are vectors of real matrices such that the i-th (cosinus) coefficient matrix  Ac_i is contained in Ac[i] and the i-th (sinus) coefficient matrix  As_i is contained in As[i]. p is the maximum of length of the vectors of matrices Ac and As.  If the length of Ac or As is less than p, then zero trailing matrices are assumed in the respective matrix.  All component matrices must have the same dimensions. The complex matrix containing the harmonic components and the period T  can be accessed via A.values and A.period, respectively.\n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#PeriodicMatrices.HarmonicArray-Union{Tuple{MT}, Tuple{T}, Tuple{MT, Union{Nothing, Vector{MT}}, Union{Nothing, Vector{MT}}, Real}} where {T<:Real, MT<:VecOrMat{T}}","page":"Constructors for periodic matrices","title":"PeriodicMatrices.HarmonicArray","text":" HarmonicArray(A0, Ac, As, T) -> A::HarmonicArray\n\nConstruct a harmonic array representation from the harmonic components.\n\nThe harmonic array object A is built for  the harmonic representation Ahr(t) of a periodic matrix of period T in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T)+As_i*sin(i*2*π*t/T) ) ,\n                i=1\n\nwhere the constant term A_0 is contained in the real matrix A0, and Ac and As are vectors of real matrices such that the i-th (cosinus) coefficient matrix  Ac_i is contained in Ac[i] and the i-th (sinus) coefficient matrix  As_i is contained in As[i]. p is the maximum of length of the vectors of matrices Ac and As.  If the length of Ac or As is less than p, then zero trailing matrices are assumed in the respective matrix.  All component matrices must have the same dimensions. The complex matrix containing the harmonic components and the period T  can be accessed via A.values and A.period, respectively.\n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#PeriodicMatrices.FourierFunctionMatrix","page":"Constructors for periodic matrices","title":"PeriodicMatrices.FourierFunctionMatrix","text":" FourierFunctionMatrix(Afun, T) -> A::FourierFunctionMatrix\n\nContinuous-time Fourier function matrix representation.\n\nThe Fourier function matrix object A of period T is built using the Fourier series representation of a periodic matrix Afun(t) of subperiod T′ = T/k,  where each entry of Afun(t) has the form\n\n         p\n  a_0 +  ∑ ( ac_i*cos(i*t*2*π/T′)+as_i*sin(i*2*π*t/T′) ) ,\n        i=1\n\nwhere k ≥ 1 is the number of subperiods (default: k = 1).    The matrix Afun containing the Fourier representation, the period T and the  number of subperiods k can be accessed via A.M, A.period and A.nperiod, respectively.\n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#PeriodicMatrices.PeriodicSwitchingMatrix","page":"Constructors for periodic matrices","title":"PeriodicMatrices.PeriodicSwitchingMatrix","text":"PeriodicSwitchingMatrix(At, ts, T; nperiod = k) -> A::PeriodicSwitchingMatrix\n\nContinuous-time periodic switching matrix representation.\n\nThe continuous-time periodic switching matrix object A of period T is built from a  p-vector At of real matrices, a p-vector ts of increasingly ordered switching time values with ts[1] = 0, and  the associated subperiod T′ = T/k, where k ≥ 1 is the number of subperiods (default: k = 1).  At contains the cyclic component matrices At[i], i = 1,..., p,  where At[i] is the constant value of a time periodic matrix A(t) of period T′ for t ∈ [ts[i],ts[i+1]), if i < p, or t ∈ [ts[i],T′), if i = p.  It is assumed that At[i] := At[mod(i-1,p)+1] and ts[i] := ts[mod(i-1,p)+1] for arbitrary i.  All component matrices must have the same dimensions. The component matrices At, the switching times ts, the period T and the number of subperiods k can be accessed via A.values, A.ts, A.period, and A.nperiod, respectively. \n\n\n\n\n\n","category":"type"},{"location":"pmtypes.html#Base.size-Tuple{PeriodicFunctionMatrix}","page":"Constructors for periodic matrices","title":"Base.size","text":"size(A::PM)\nsize(A::PM[, dim])\n\nReturn a tuple of two integers containing the dimensions of the continuous-time periodic matrix A of type PM, where PM is one of the types PeriodicFunctionMatrix, HarmonicArray, PeriodicTimeSeriesMatrix, PeriodicSwitchingMatrix,  PeriodicSymbolicMatrix or PeriodicFunctionMatrix.  Optionally you can specify a dimension dim to just get the length of that dimension.\n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.eltype-Tuple{PeriodicFunctionMatrix}","page":"Constructors for periodic matrices","title":"Base.eltype","text":"eltype(A::PM)\n\nDetermine the type of the elements of the continuous-time periodic matrix A of type PM, where PM is one of the types PeriodicFunctionMatrix, HarmonicArray, PeriodicTimeSeriesMatrix, PeriodicSwitchingMatrix,  PeriodicSymbolicMatrix or PeriodicFunctionMatrix.  \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.getindex-Tuple{PeriodicFunctionMatrix, Vararg{Any}}","page":"Constructors for periodic matrices","title":"Base.getindex","text":"getindex(A::PM, ind1, ind2)\n\nReturn the continuous-time periodic matrix built from the selected ranges [ind1,ind2] of the elements of the continuous-time periodic matrix Aof type PM, where PM is one of the types PeriodicFunctionMatrix, HarmonicArray, PeriodicTimeSeriesMatrix, PeriodicSwitchingMatrix,  PeriodicSymbolicMatrix or PeriodicFunctionMatrix.    ind1 and ind2 may be integers, integer ranges or colons.  \n\n\n\n\n\n","category":"method"},{"location":"pmtypes.html#Base.lastindex-Tuple{PeriodicFunctionMatrix, Int64}","page":"Constructors for periodic matrices","title":"Base.lastindex","text":"lastindex(A::PM,dim)\n\nReturn the last index along dimension dim of the continuous-time periodic matrix A of type PM, where PM is one of the types PeriodicFunctionMatrix, HarmonicArray, PeriodicTimeSeriesMatrix, PeriodicSwitchingMatrix,  PeriodicSymbolicMatrix or PeriodicFunctionMatrix.   \n\n\n\n\n\n","category":"method"},{"location":"pmutilities.html#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"pmutilities.html","page":"Utilities","title":"Utilities","text":"peigvals   Eigenvalues of a cyclic matrix product.\nts2fm   Compute the function matrix to interpolate a matrix time series.\npsreduc_reg  Fast reduction of a lifted regular pencil corresponding to a product of matrices. ","category":"page"},{"location":"pmutilities.html","page":"Utilities","title":"Utilities","text":"PeriodicMatrices.peigvals(A::Array{T, 3}; rev, fast) where T\nPeriodicMatrices.peigvals(A::Array{Matrix{T}, 1}, k::Int64; rev, fast) where T\nts2fm\npsreduc_reg","category":"page"},{"location":"pmutilities.html#PeriodicMatrices.peigvals-Union{Tuple{Array{T, 3}}, Tuple{T}} where T","page":"Utilities","title":"PeriodicMatrices.peigvals","text":" ev = peigvals(A::Array{T,3}; rev = true, fast = false)\n\nCompute the eigenvalues of a product of p square matrices  A(p)...*A(2)*A(1), if rev = true (default) (also called characteristic multipliers) or  of A(1)*A(2)...A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix A(i) is contained in A[:,:,i]. If fast = false (default) then the eigenvalues are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed. This later option may occasionally lead to inaccurate results for large number of matrices. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"method"},{"location":"pmutilities.html#PeriodicMatrices.peigvals-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Int64}} where T","page":"Utilities","title":"PeriodicMatrices.peigvals","text":" ev = peigvals(A::Vector{Matrix}[, k = 1]; rev = true, fast = false)\n\nCompute the eigenvalues of a square cyclic product of p matrices  A(k-1)...*A(2)*A(1)*A(p)...*A(k), if rev = true (default) or  A(k)*A(k+1)*...A(p)*A(1)...A(k-1) if rev = false, without evaluating the product.  The argument k specifies the starting index (default: k = 1).  The matrices A(1), ..., A(p) are contained in the p-vector of matrices A  such that the i-th matrix  A(i), of dimensions m(i)×n(i), is contained in A[i]. If fast = false (default) then the eigenvalues are computed using an approach based on the periodic Schur decomposition [1], while if fast = true  the structure exploiting reduction [2] of an appropriate lifted pencil is employed.  This later option may occasionally lead to inaccurate results for large number of matrices. \n\nNote: The first nmin components of ev contains the core eigenvalues of the appropriate matrix product, where nmin is the minimum row dimensions of matrices A[i], for i = 1, ..., p,  while the last ncur-nmin components of ev are zero,  where ncur is the column dimension of A[k] if rev = true or  the row dimension of A[k] if rev = false. \n\nReferences\n\n[1] A. Bojanczyk, G. Golub, and P. Van Dooren,      The periodic Schur decomposition. Algorithms and applications, Proc. SPIE 1996.\n\n[2] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"method"},{"location":"pmutilities.html#PeriodicMatrices.ts2fm","page":"Utilities","title":"PeriodicMatrices.ts2fm","text":" ts2fm(A::Vector{<:AbstractMatrix}, period; method = \"linear\") -> At::Function\n\nCompute the function matrix corresponding to an interpolated matrix time series.  For the given matrix time series A, a function matrix A(t) is defined as the  mapping A(t) = t -> etpf(t), where etpf(t) is an interpolation object,   as provided in the Interpolations.jl  package.  The keyword parameter method specifies the interpolation method to be used as follows:\n\nmethod = \"constant\" - use periodic B-splines of degree 0 (constant interpolation);\n\nmethod = \"linear\" - use periodic B-splines of degree 1 (linear interpolation) (default);\n\nmethod = \"quadratic\" - use periodic B-splines of degree 2 (quadratic interpolation); \n\nmethod = \"cubic\" - use periodic B-splines of degree 3 (cubic interpolation). \n\n\n\n\n\n","category":"function"},{"location":"pmutilities.html#PeriodicMatrices.psreduc_reg","page":"Utilities","title":"PeriodicMatrices.psreduc_reg","text":"psreduc_reg(A) -> (M, N)\n\nDetermine for a n×n×p array A, the matrix pair (M, N)  with N invertible and M-λN regular, such that  the eigenvalues of M-λN are the same as those of the matrix product A(p)*A(p-1)*...*A(1), where A(i) is contained in A[:,:,i].  The structure exploiting fast reduction method of [1] is employed to determine M and N.\n\n[1] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\npsreduc_reg(A,E) -> (M, N)\n\nDetermine for a pair of n×n×p arrays (A,E), the matrix pair (M, N)  with M-λN regular, such that  the eigenvalues of M-λN are the same as those of the quotient matrix product inv(E(p))*(A(p)*inv(E(p-1))*A(p-1)*...*inv(E(1))*A(1), where A(i) is contained in A[:,:,i] and E(i) is contained in E[:,:,i].  The structure exploiting fast reduction method of [1] is employed to determine M and N.\n\n[1] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\npsreduc_reg(A) -> (M, N)\n\nDetermine for a p-dimensional vector of rectangular matrices A,  the matrix pair (M, N) with N invertible and M-λN regular, such that  the eigenvalues of M-λN are the same as those of the square  matrix product A(p)*A(p-1)*...*A(1), where A(i) is contained in A[i].  The structure exploiting fast reduction method of [1] is employed to determine M and N.\n\n[1] A. Varga & P. Van Dooren. Computing the zeros of periodic descriptor systems.     Systems and Control Letters, 50:371-381, 2003.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#Periodic-Schur-decompositions","page":"Periodic Schur Decomposition","title":"Periodic Schur decompositions","text":"","category":"section"},{"location":"pschur.html","page":"Periodic Schur Decomposition","title":"Periodic Schur Decomposition","text":"phess  Periodic Hessenberg decomposition of a product of matrices.\nphess!  Periodic Hessenberg decomposition of a product of matrices (in place computation).\npschur  Periodic Schur decompositions of products or quotient products of matrices. \npschur!  Periodic Schur decompositions of products of matrices (in place computation). \npsordschur!  Reordering of periodic Schur decompositions of products or quotient products of matrices.\npsordschur1!  Reordering of periodic Schur decompositions of products or quotient products of square matrices.\npgschur  Generalized real periodic Schur decomposition of a formal product of matrices.\npgschur!  Generalized real periodic Schur decompositions of formal products of matrices (in place computation).\npgordschur!  Reordering of generalized real periodic Schur decompositions a formal products of matrices.","category":"page"},{"location":"pschur.html","page":"Periodic Schur Decomposition","title":"Periodic Schur Decomposition","text":"phess\nphess!\npschur\npschur!\nPeriodicMatrices.ws_pschur\npsordschur!\npsordschur1!\npgschur\npgschur!\npgordschur!","category":"page"},{"location":"pschur.html#PeriodicMatrices.phess","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.phess","text":" phess(A::Array{Float64,3}; hind = 1, rev = true, withZ = true) -> (H, Z, ihess)\n phess1(A::Array{Float64,3}; hind = 1, rev = true, withZ = true) -> (H, Z, ihess)\n\nCompute the Hessenberg decomposition of a product of square matrices  A(p)*...*A(2)*A(1), if rev = true (default) or A(1)*A(2)*...*A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix A(i) is contained in A[:,:,i]. The resulting n×n×p arrays H and Z contain the matrices H(1), ..., H(p) and the orthogonal matrices Z(1), ..., Z(p), respectively,  such that for rev = true\n\n       Z(2)' * A(1) * Z(1) = H(1),\n       Z(3)' * A(2) * Z(2) = H(2),\n              ...\n       Z(1)' * A(p) * Z(p) = H(p),\n\nand for rev = false\n\n       Z(1)' * A(1) * Z(2) = H(1),\n       Z(2)' * A(2) * Z(3) = H(2),\n              ...\n       Z(p)' * A(p) * Z(1) = H(p).\n\nIf hind = ihess, with 1 ≤ ihess ≤ p (default ihess = 1), then  H(i), i = 1, ..., p are in a periodic Hessenberg form,  with H(ihess) in upper Hessenberg form and H(i)  upper triangular for i neq ihess.  H(i) and Z(i) are contained in H[:,:,i] and Z[:,:,i], respectively.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe function phess is based on a wrapper for the SLICOT subroutine MB03VW    (see PeriodicMatrices.SLICOTtools.mb03vw!).\n\nThe function phess1 is based on wrappers for the SLICOT subroutines MB03VD   (see PeriodicMatrices.SLICOTtools.mb03vd!) and MB03VY  (see PeriodicMatrices.SLICOTtools.mb03vy!).\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.phess!","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.phess!","text":" phess!(A::Array{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); kwargs...) -> (H, Z, ihess)\n\nSame as phess(A; kwargs...) but uses the input matrix A as workspace and specifies a range ilh = (ilo, ihi), such that all matrices A(j), j = 1, ..., p, are already in periodic Hessenberg forms in rows and columns 1:ilo-1 and ihi+1:n, where n is the first dimension of A.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.pschur","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.pschur","text":" pschur(A::Array{Float64,3}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n pschur1(A::Array{Float64,3}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n pschur2(A::Array{Float64,3}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the Schur decomposition of a product of square matrices  A(p)*...*A(2)*A(1), if rev = true (default) or A(1)*A(2)*...*A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix A(i) is contained in A[:,:,i]. The resulting n×n×p arrays S and Z contain the matrices S(1), ..., S(p) and the orthogonal matrices Z(1), ..., Z(p), respectively,  such that for rev = true\n\n       Z(2)' * A(1) * Z(1) = S(1),\n       Z(3)' * A(2) * Z(2) = S(2),\n              ...\n       Z(1)' * A(p) * Z(p) = S(p),\n\nand for rev = false\n\n       Z(1)' * A(1) * Z(2) = S(1),\n       Z(2)' * A(2) * Z(3) = S(2),\n              ...\n       Z(p)' * A(p) * Z(1) = S(p).\n\nIf sind = ischur, with 1 ≤ ischur ≤ p (default ischur = 1), then  S(i), for i = 1, ..., p are in a periodic Schur form,  with S(ischur) in quasi-upper triangular (or Schur) form and S(i)  upper triangular for i neq ischur.  S(i) and Z(i) are contained in S[:,:,i] and Z[:,:,i], respectively.  The vector ev contains the eigenvalues of the appropriate matrix product.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW   (see PeriodicMatrices.SLICOTtools.mb03vw!) and MB03BD  (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nThe function pschur1 is based on wrappers for the SLICOT subroutines MB03VD  (see PeriodicMatrices.SLICOTtools.mb03vd!),  MB03VY  (see PeriodicMatrices.SLICOTtools.mb03vy!)  and MB03BD  (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nThe function pschur2 is based on wrappers for the SLICOT subroutines MB03VD  (see PeriodicMatrices.SLICOTtools.mb03vd!),  MB03VY  (see PeriodicMatrices.SLICOTtools.mb03vy!) and MB03VW  (see PeriodicMatrices.SLICOTtools.mb03vw!),  based on the algorithm proposed in [1]. Known issue: MB03VW may fails for larger periods. \n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pschur(A::Vector{Matrix{T}}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n pschur1(A::Vector{Matrix{T}}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the extended periodic Schur decomposition of a square product of matrices  A(p)*...*A(2)*A(1), if rev = true (default) or A(1)*A(2)*...*A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the p-vector of matrices A  such that the i-th matrix  A(i), of dimensions m(i)×n(i), is contained in A[i]. The resulting p-vectors S and Z contain the matrices S(1), ..., S(p) and the orthogonal matrices Z(1), ..., Z(p), respectively,  such that for rev = true\n\n       Z(2)' * A(1) * Z(1) = S(1),\n       Z(3)' * A(2) * Z(2) = S(2),\n              ...\n       Z(1)' * A(p) * Z(p) = S(p),\n\nand for rev = false\n\n       Z(1)' * A(1) * Z(2) = S(1),\n       Z(2)' * A(2) * Z(3) = S(2),\n              ...\n       Z(p)' * A(p) * Z(1) = S(p).\n\nThe resulting index ischur is determined such that m(ischur) ≤ m(i), ∀i. The resulting S(i), for i = 1, ..., p are in an extended  periodic Schur form,  with S(ischur) in a quasi-upper trapezoidal form and S(i)  upper trapezoidal for i neq ischur.  S(i) and Z(i) are contained in S[i] and Z[i], respectively.  The first nmin components of ev := α .* γ contain the core eigenvalues of the appropriate matrix product, where nmin = m(ischur), while the last nmax-nmin components of ev are zero,  where nmax is the largest row or column dimension of A(i), for i = 1, ..., p.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW (see PeriodicMatrices.SLICOTtools.mb03vw!)  and MB03BD (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nThe function pschur1 is based on wrappers for the SLICOT subroutines MB03VD (see PeriodicMatrices.SLICOTtools.mb03vd!),  MB03VY (see PeriodicMatrices.SLICOTtools.mb03vy!),  and MB03BD (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pschur(A::AbstractArray{T,3}, E::AbstractArray{T,3}; rev = true, withZ = true) -> (S, T, Q, Z, ev, ischur, α, γ)\n\nCompute the periodic Schur decomposition of a square formal quotient product of matrices  inv(E(p))*A(p)*...*inv(E(2))*A(2)*inv(E(1))*A(1), if rev = true (default) or  A(1)*inv(E(1))*A(2)*inv(E(2))*...*A(p)*inv(E(p)) if rev = false, without evaluating the product and the inverses.  The matrices A(1), ..., A(p) are contained in the n×n×p-array A  such that the i-th matrix  A(i) is contained in A[:,:,i]. The square matrices E(1), ..., E(p) are contained in the n×n×p-array E  such that the i-th matrix  E(i) is contained in E[:,:,i].\n\nThe resulting n×n×p-arrays S, T, Q and Z contain, respectively,  the matrices S(1), ..., S(p) with S(ischur) in a quasi-upper trapezoidal form and  S(i) upper trapezoidal for i neq ischur, the upper triangular matrices T(1), ..., T(p),  the orthogonal matrices Q(1), ..., Q(p), and Z(1), ..., Z(p),  such that for rev = true\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(1)' * E(1) * Z(2) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(2)' * E(2) * Z(3) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(p)' * E(p) * Z(1) = T(p),\n\nand for rev = false\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(2)' * E(1) * Z(1) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(3)' * E(2) * Z(2) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(1)' * E(p) * Z(p) = T(p),\n\nThe complex vector ev contains the eigenvalues of the appropriate matrix product, and can be alternatively expressed as ev := α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case  Q = nothing and Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW (see PeriodicMatrices.SLICOTtools.mb03vw!)  and MB03BD (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pschur(A::Vector{Matrix{T}}, E::Vector{Matrix{T}}; rev = true, withZ = true) -> (S, T, Q, Z, ev, ischur, α, γ)\n\nCompute the extended periodic Schur decomposition of a square formal product of matrices  inv(E(p))*A(p)*...*inv(E(2))*A(2)*inv(E(1))*A(1), if rev = true (default) or  A(1)*inv(E(1))*A(2)*inv(E(2))*...*A(p)*inv(E(p)) if rev = false, without evaluating the product and the inverses.  The matrices A(1), ..., A(p) are contained in the p-vector of matrices A  such that the i-th matrix  A(i), of dimensions m(i)×n(i), is contained in A[i]. The square matrices E(1), ..., E(p) are contained in the p-vector of matrices E  such that the i-th matrix  E(i), of dimensions m(i)×m(i) if rev = true or n(i)×n(i) if rev = false,  is contained in E[i].\n\nThe resulting index ischur is determined such that m(ischur) ≤ m(i), ∀i. The resulting p-vectors S, T, Q and Z contain, respectively,  the matrices S(1), ..., S(p) with S(ischur) in a quasi-upper trapezoidal form and  S(i) upper trapezoidal for i neq ischur, the upper triangular matrices T(1), ..., T(p),  the orthogonal matrices Q(1), ..., Q(p), and Z(1), ..., Z(p),  such that for rev = true\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(1)' * E(1) * Z(2) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(2)' * E(2) * Z(3) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(p)' * E(p) * Z(1) = T(p),\n\nand for rev = false\n\n       Q(1)' * A(1) * Z(1) = S(1),  Q(2)' * E(1) * Z(1) = T(1), \n       Q(2)' * A(2) * Z(2) = S(2),  Q(3)' * E(2) * Z(2) = T(2),\n              ...\n       Q(p)' * A(p) * Z(p) = S(p),  Q(1)' * E(p) * Z(p) = T(p),\n\nThe first nmin components of ev := α .* γ contain the core eigenvalues of the appropriate matrix product, where nmin = m(ischur), while the last nmax-nmin components of ev are zero,  where nmax is the largest row or column dimension of A(i), for i = 1, ..., p.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues.  The performed orthogonal transformations are not accumulated if withZ = false,  in which case  Q = nothing and Z = nothing. \n\nThe function pschur is based on wrappers for the SLICOT subroutines MB03VW (see PeriodicMatrices.SLICOTtools.mb03vw!)  and MB03BD (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.pschur!","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.pschur!","text":" pschur!(A::Array{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); kwargs...) -> (S, Z, ihess)\n\nSame as pschur(A; kwargs...) but uses the input matrix A as workspace and specifies a range ilh = (ilo, ihi), such that all matrices A(j), j = 1, ..., p, are already in periodic Schur forms in rows and columns 1:ilo-1 and ihi+1:n, where n is the first dimension of A.\n\n\n\n\n\n pschur!(A::Array{Float64,3}, Z::AbstractArray{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); rev = true, sind = 1, withZ = true) -> (ev, sind, α, γ)\n pschur!(wspace::Tuple, A::Array{Float64,3}, Z::AbstractArray{Float64,3}, ilh::Tuple(Int,Int) = (1, size(A,1)); rev = true, sind = 1, withZ = true) -> (ev, sind, α, γ)\n\nCompute the Schur decomposition of a product of square matrices  A(p)*...*A(2)*A(1), if rev = true (default) or A(1)*A(2)*...*A(p) if rev = false, without evaluating the product.  The matrices A(1), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix A(i) is contained in A[:,:,i].  A range ilh = (ilo, ihi) can be specified, such that all matrices A(j), j = 1, ..., p, are already in periodic Schur forms in rows and columns 1:ilo-1 and ihi+1:n, where n is the first dimension of A. The resulting reduced matrices S(1), ..., S(p), representing the periodic Schur decimposition  overwrite the input matrices A(1), ..., A(p). If withZ = true, then Z must contain on input an n×n×p array, which will be overwritten on output with the orthogonal matrices Z(1), ..., Z(p) used for reduction.  If withZ = false, orthogonal transformations are not computed and Z can be an arbiitrary three-dimensional array (e.g., an empty 0×0×0 array).  The resulting reduced matrices S(1), ..., S(p) and the orthogonal transformation matrices Z(1), ..., Z(p),  satisfy for rev = true\n\n       Z(2)' * A(1) * Z(1) = S(1),\n       Z(3)' * A(2) * Z(2) = S(2),\n              ...\n       Z(1)' * A(p) * Z(p) = S(p),\n\nand for rev = false\n\n       Z(1)' * A(1) * Z(2) = S(1),\n       Z(2)' * A(2) * Z(3) = S(2),\n              ...\n       Z(p)' * A(p) * Z(1) = S(p).\n\nIf sind = ischur, with 1 ≤ ischur ≤ p (default ischur = 1), then  S(i), for i = 1, ..., p are in a periodic Schur form,  with S(ischur) in quasi-upper triangular (or Schur) form and S(i)  upper triangular for i neq ischur.  The vector ev contains the eigenvalues of the appropriate matrix product.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues. \n\nTo reduce the number of allocations when the periodic Schur decomposition needs to be repeteadly computed,  the internally needed workspace can be pre-allocated in a tuple wspace using the function PeriodicMatrices.ws_pschur). \n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.ws_pschur","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.ws_pschur","text":" ws_pschur(A::Array{Float64,3}) -> (QIND, SIND, ALPHAR, ALPHAI, BETA, SCAL, IWORK, DWORK)\n\nAllocate workspaces for the function pschur! to call the SLICOT-based wrappers mb03vw! and mb03bd! avoiding additional allocations.     \n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.psordschur!","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.psordschur!","text":" psordschur!(S::Vector{Matrix{Float64}}, Z::Vector{Matrix{Float64}}, select; rev, schurindex)\n\nReorder the core eigenvalues of the product Π = S[p]*...*S[2]*S[1], if rev = true (default) or Π = S[1]*S[2]*...*S[p] if rev = false, where Π is in real Schur form, such that the selected eigenvalues in the logical array select are moved into the leading positions.  The p-vectors S and Z contain the matrices S[1], ..., S[p] in an extended periodic Schur form, with the leading square block of  S[schurindex] in real Schur form, and the corresponding orthogonal transformation matrices Z[1], ..., Z[p], respectively.  S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.  The dimension of select must be equal to the number of core eigenvalues (i.e., the minimum dimension of matrices in the vector S).  \n\n\n\n\n\n psordschur!(S::Array{Float64,3}, Z::Array{Float64,3}, select::Union{Vector{Bool},BitVector}; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[:,:,p]*...*S[:,:,2]*S[:,:,1], if rev = true (default) or Π = S[:,:,1]*S[:,:,2]*...*S[:,:,p] if rev = false, where Π is in real Schur form, such that the selected eigenvalues in the logical array select are moved into the leading positions.  The 3-dimensional arrays S and Z contain the matrices S[:,:,1], ..., S[:,:,p] in a periodic Schur form, with S[:,:,schurindex] in real Schur form,  and the corresponding orthogonal transformation matrices Z[:,:,1], ..., Z[:,:,p], respectively.  S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.psordschur1!","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.psordschur1!","text":" psordschur1!(S::Vector{Matrix{Float64}}, Z::Vector{Matrix{Float64}}, select; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[p]*...*S[2]*S[1], if rev = true (default) or Π = S[1]*S[2]*...*S[p] if rev = false, where Π is in real Schur form, such that the selected eigenvalues in the logical array select are moved into the leading positions.  The p-vectors S and Z contain, respectively, the square matrices S[1], ..., S[p] in a periodic Schur form, with S[schurindex] in real Schur form,  and the corresponding orthogonal transformation matrices Z[1], ..., Z[p], respectively.  S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.pgschur","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.pgschur","text":" pgschur(A::Vector{Matrix}, s::Union{Vector{Bool},BitVector}; rev = true, withZ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the generalized real periodic Schur decomposition of a formal product of square matrices  A(p)^s(p)*...A(2)^s(2)*A(1)^s(1), if rev = true (default), or  A(1)^s(1)*A(2)^s(2)*...*A(p)^s(p), if rev = false, where 's(j) = ±1'.  The matrices A(1), A(2), ..., A(p) are contained in the p-dimensional array A  such that the i-th matrix  A(i) is contained in A[i]. \n\nThe resulting p-dimensional array S contains the matrices S(1), ..., S(p)  such that the i-th matrix S(i) is contained in S[i].  The component matrix S[ischur] is in a quasi-upper triangular form, while S[i] is upper triangular for i neq ischur.  If withZ = true (default), the resulting p-dimensional array Z contains the orthogonal transformation  matrices Z(1), ..., Z(p) such that the i-th matrix Z(i) is contained in Z[i].  The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe resulting matrices satisfy for rev = true\n\n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = true, \n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = false,\n\nand for rev = false\n\n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = true, \n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = false.\n\nThe vector ev contains the eigenvalues of the appropriate matrix product.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues. \n\nThe function pgschur is based on wrappers for the SLICOT subroutines MB03VW   (see PeriodicMatrices.SLICOTtools.mb03vw!) and MB03BD  (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n pgschur(A::Array{Float64,3}, s::Union{Vector{Bool},BitVector}; rev = true, withQ = true) -> (S, Z, ev, ischur, α, γ)\n\nCompute the generalized real periodic Schur decomposition of a formal product of square matrices  A(p)^s(p)*...A(2)^s(2)*A(1)^s(1), if rev = true (default), or  A(1)^s(1)*A(2)^s(2)*...*A(p)^s(p), if rev = false, where 's(j) = ±1'.  The matrices A(1), A(2), ..., A(p) are contained in the n×n×p array A  such that the i-th matrix  A(i) is contained in A[:,:,i]. \n\nThe resulting n×n×p array S contains the matrices S(1), ..., S(p)  such that S(ischur) is in a quasi-upper triangular form,  S(i) is upper triangular for i neq ischur.  If withZ = true (default), the resulting n×n×p array Z contains the orthogonal transformation  matrices Z(1), ..., Z(p). The performed orthogonal transformations are not accumulated if withZ = false,  in which case Z = nothing. \n\nThe resulting matrices satisfy for rev = true\n\n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = true, \n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = false,\n\nand for rev = false\n\n       Z(j)' * A(j) * Z(mod(j,p)+1) = S(j),  if S[j] = true, \n       Z(mod(j,p)+1)' * A(j) * Z(j) = S(j),  if S[j] = false.\n\nS(i) and Z(i) are contained in S[:,:,i] and Z[:,:,i], respectively.  The vector ev contains the eigenvalues of the appropriate matrix product.  The eigenvalues can be alternatively expressed as α .* γ, where γ contains suitable  scaling parameters to avoid overflows or underflows in the expressions of the eigenvalues. \n\nThe function pgschur is based on wrappers for the SLICOT subroutines MB03VW   (see PeriodicMatrices.SLICOTtools.mb03vw!) and MB03BD  (see PeriodicMatrices.SLICOTtools.mb03bd!),  based on algorithms proposed in [1] and [2].\n\nREFERENCES\n\n[1] Bojanczyk, A., Golub, G. H. and Van Dooren, P.     The periodic Schur decomposition: algorithms and applications.     In F.T. Luk (editor), Advanced Signal Processing Algorithms,     Architectures, and Implementations III, Proc. SPIE Conference,     vol. 1770, pp. 31-42, 1992.\n\n[2] Kressner, D.     An efficient and reliable implementation of the periodic QZ     algorithm. IFAC Workshop on Periodic Control Systems (PSYCO     2001), Como (Italy), August 27-28 2001. Periodic Control     Systems 2001 (IFAC Proceedings Volumes), Pergamon.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.pgschur!","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.pgschur!","text":"pgschur!(A::Array{Float64,3}, S::Union{Vector{Bool},BitVector}; kwargs...)\n\nSame as pgschur but uses the input matrix A as workspace.\n\n\n\n\n\n","category":"function"},{"location":"pschur.html#PeriodicMatrices.pgordschur!","page":"Periodic Schur Decomposition","title":"PeriodicMatrices.pgordschur!","text":" pgordschur!(S::Array{Float64,3}, s::Union{Vector{Bool},BitVector}, Z::Array{Float64,3}, select::Union{Vector{Bool},BitVector}; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[:,:,p]^s[p]*...*S[:,:,2]^s[2]*S[:,:,1]^s[1], if rev = true (default) or  Π = S[:,:,1]^s[1]*S[:,:,2]^s[2]*...*S[:,:,p]^s[p] if rev = false, with 's[j] = ±1', where Π is in a real Schur form,  such that the selected eigenvalues in the logical array select are moved into the leading positions.  The 3-dimensional arrays S and Z contain the matrices S[:,:,1], ..., S[:,:,p] in a generalized periodic Schur form,  with S[:,:,schurindex] in a quasi-upper triangular (real Schur) form,  and the corresponding orthogonal transformation matrices Z[:,:,1], ..., Z[:,:,p], respectively.   S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n pgordschur!(S::Vector{Matrix{Float64}}, s::Union{Vector{Bool},BitVector}, Z::Vector{Matrix{Float64}}, select::Union{Vector{Bool},BitVector}; rev, schurindex)\n\nReorder the eigenvalues of the product Π = S[p]^s[p]*...*S[2]^s[2]*S[1]^s[1], if rev = true (default) or  Π = S[1]^s[1]*S[2]^s[2]*...*S[p]^s[p] if rev = false, with 's[j] = ±1', where Π is in a real Schur form,  such that the selected eigenvalues in the logical array select are moved into the leading positions.  The p-vectors S and Z contain the matrices S[1], ..., S[p] in a generalized periodic Schur form,  with S[schurindex] in a quasi-upper triangular (real Schur) form,  and the corresponding orthogonal transformation matrices Z[1], ..., Z[p], respectively.   S and Z are overwritten by the updated matrices.  A conjugate pair of eigenvalues must be either both included or both excluded via select.    \n\n\n\n\n\n","category":"function"},{"location":"index.html","page":"Home","title":"Home","text":"CurrentModule = PeriodicMatrices\nDocTestSetup = quote\n    using PeriodicMatrices\nend","category":"page"},{"location":"index.html#PeriodicMatrices.jl","page":"Home","title":"PeriodicMatrices.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"PeriodicMatrices.jl provides the basic tools to handle periodic time-varying matrices.  The time dependence can be either continuous or discrete. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic matrices appear in many control applications involving periodic phenomena as for example, satellite attitude control, helicopter forward flight control,  orbital stabilization of underactuated systems, control of multi-rate sampled-data systems, etc. These problems can be addressed using tools available in  the PeriodicSystems package, which is based on the periodic matrix type defined in this package.  ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A continuous-time periodic matrix can be specified in the following forms:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"periodic matrix function\nharmonic matrix series\nperiodic matrix time series with uniform time grid \nperiodic matrix time series with non-uniform time grid (also known as periodic switching matrix)\nperiodic symbolic matrix\nFourier matrix series approximation   ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A discrete-time periodic matrix can be specified in the following forms:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"periodic matrix time series with time-varying dimensions with uniform time grid\nperiodic matrix time series with time-varying dimensions with non-uniform time grid\nperiodic matrix time series with constant dimensions with uniform time grid\nperiodic matrix time series with constant dimensions with non-uniform time grid","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"For a periodic matrix A(t) of period T it is not assumed that T is the minimum value which satisfies the periodicity condition A(t) = A(t+T) for all values of t. To describe  matrices having multiple periods, a subperiod Tsub := T/n can be defined, such that A(t) = A(t+Tsub), for all t. This allows a substantial memory saving for some classes of periodic representations. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Several operations on periodic matrices are implemented, such as, inversion, transposing, norms, derivative/shifting, trace. All operations with two periodic matrices such as addition/substraction, multiplication, horizontal/vertical concatenation, block-diagonal appending, allow different, but commensurate, periods/subperiods.  ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Functions are provided to compute the characteristic multipliers and characteristic exponents of periodic matrices, using methods based on the periodic Schur decomposition of matrix products  or structure exploitung fast algorithms.  These functions are instrumental to apply Floquet theory to study the properties of solutions of  various classes of differential equations (Mathieu, Hill, Meissner) and the stability of linear periodic systems (see PeriodicSystems package). ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The following categories of functions are currently implemented:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Constructors for periodic matrices","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"PeriodicMatrix   Discrete-time periodic matrix representation.\nPeriodicArray    Discrete-time periodic array representation.\nSwitchingPeriodicMatrix Discrete-time switching periodic matrix representation.\nSwitchingPeriodicArray Discrete-time switching periodic array representation.\nPeriodicFunctionMatrix  Continuous-time periodic function matrix representation.\nPeriodicSymbolicMatrix   Continuous-time periodic symbolic matrix representation.\nPeriodicTimeSeriesMatrix   Continuous-time periodic time series matrix representation.\nHarmonicArray   Continuous-time harmonic array representation.\nFourierFunctionMatrix   Continuous-time Fourier functin matrix representation.\nPeriodicSwitchingMatrix Continuous-time switching periodic matrix representation.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic matrix conversions","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"ts2hr   Conversion of  a periodic time series matrix to a harmonic array approximation.\npfm2hr  Conversion of  a periodic function matrix to a harmonic array representation. \nts2pfm  Conversion of  an interpolated periodic time series matrix to a periodic function matrix.\nhr2psm  Conversion of  a harmonic array representation to a periodic symbolic matrix.\npsm2hr  Conversion of  a periodic symbolic matrix into a harmonic array representation.\npm2pa   Conversion of  a discrete-time periodic matrix object to a periodic array object.\nffm2hr  Conversion of  a Fourier function matrix to a harmonic array representation. \nhr2bt   Building a block Toeplitz matrix approximation of a harmonic (Fourier) array representation. \nhr2btupd  Building an updated block Toeplitz matrix approximation of a harmonic (Fourier) array representation. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A comprehensive set of conversions between discrete-time models and between continuous-time models is implemented via the convert function.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic matrix utilities","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pseig   Characteristic multipliers of a periodic matrix.\npseigsm   Characteristic multipliers of a periodic symbolic matrix.\npsceig   Characteristic exponents of a periodic matrix.\npsceighr   Characteristic exponents of a periodic matrix in Harmonic Array representation.\npsceigfr   Characteristic exponents of a periodic matrix in Fourier Function Matrix representation.\npsceigsm   Characteristic exponents of a periodic matrix in symbolic representation.\nmonodromy  Monodromy matrix of a linear periodic time-varying system of ODE.\ntvstm  State transition matrix of a linear time-varying system of ODE.\npsreduc_reg  Fast reduction of a lifted regular pencil corresponding to a product of matrices. \ntvmeval  Time response evaluation of a continuous-time periodic matrix. \nhreval  Evaluation of a harmonic array for a numerical or symbolic time value. \nhrchop  Removal of the negligible trailing terms of a harmonic representation. \nhrtrunc  Truncation of a harmonic representation.  \npmaverage  Evaluation of the time averaged matrix of a continuous-time periodic matrix. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Periodic Schur decompositions","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"phess  Periodic Hessenberg decomposition of a product of matrices.\npschur  Periodic Schur decompositions of products or quotient products of matrices. \npsordschur!  Reordering of periodic Schur decompositions of products or quotient products of matrices.\npsordschur1!  Reordering of periodic Schur decompositions of products or quotient products of square matrices.\npgschur  Generalized real periodic Schur decomposition of a formal product of matrices.\npgschur  Generalized real periodic Schur decomposition of a formal product of matrices.\npgschur!  Generalized real periodic Schur decompositions of formal products of matrices (in place computation).\npgschur  Generalized real periodic Schur decompositions of formal products of matrices.\npgordschur!  Reordering of generalized real periodic Schur decompositions a formal products of matrices.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/PeriodicMatrices.jl/blob/master/ReleaseNotes.md)","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"[1] A. Varga. A Periodic Systems Toolbox for Matlab. Proc. of IFAC 2005 World Congress, Prague, Czech Republic, 2005.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[2] S. Bittanti and P. Colaneri. Periodic Systems - Filtering and Control, Springer Verlag, 2009.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"[3] J. A. Richards. Analysis of Periodically Time-Varying Systems, Springer Verlag, 1983.","category":"page"},{"location":"makeindex.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html","page":"Index","title":"Index","text":"Pages = [ \"pmconv.md\", \"pmtypes.md\", \"pmops.md\", \"pschur.md\", \"pmtools.md\", \"slicot.md\" ]\nModules = [PeriodicMatrices]\nOrder = [:type, :function]","category":"page"},{"location":"pmconv.html#Periodic-matrix-conversions","page":"Periodic matrix conversions","title":"Periodic matrix conversions","text":"","category":"section"},{"location":"pmconv.html","page":"Periodic matrix conversions","title":"Periodic matrix conversions","text":"convert   Conversion between discrete-time and between continuous-time periodic matrix representations.\nts2hr   Conversion of  a periodic time series matrix to a harmonic array approximation.\npfm2hr  Conversion of  a periodic function matrix to a harmonic array representation. \nts2pfm  Conversion of  an interpolated periodic time series matrix to a periodic function matrix.\nhr2psm  Conversion of  a harmonic array representation to a symbolic matrix.\npsm2hr  Conversion of  a periodic symbolic matrix into a harmonic array representation.\npm2pa   Conversion of  a discrete-time periodic matrix object to a periodic array object.\nffm2hr  Conversion of  a Fourier function matrix to a harmonic array representation. \nffm2psm  Conversion of a Fourier function matrix to a symbolic matrix. \nhr2bt   Building a block Toeplitz matrix approximation of a harmonic (Fourier) array representation. \nhr2btupd  Building an updated block Toeplitz matrix approximation of a harmonic (Fourier) array representation. ","category":"page"},{"location":"pmconv.html","page":"Periodic matrix conversions","title":"Periodic matrix conversions","text":"convert(::Type{<:PeriodicMatrix}, A::PeriodicArray{:d, T}) where T\nconvert(::Type{PeriodicFunctionMatrix}, ahr::HarmonicArray)\nts2hr\npfm2hr\nts2pfm\nhr2psm\npsm2hr\npm2pa\nffm2hr\nffm2psm\nhr2bt\nhr2btupd","category":"page"},{"location":"pmconv.html#Base.convert-Union{Tuple{T}, Tuple{Type{<:PeriodicMatrix}, PeriodicArray{:d, T}}} where T","page":"Periodic matrix conversions","title":"Base.convert","text":"convert(PM1,A::PM2) -> B::PM1\n\nConvert the discrete-time periodic matrix A of type PM2 to the discrete-time periodic matrix B of type PM1,  where PM1 and PM2 are of types PeriodicMatrix, SwitchingPeriodicMatrix, PeriodicArray or SwitchingPeriodicArray.\n\n\n\n\n\n","category":"method"},{"location":"pmconv.html#Base.convert-Tuple{Type{PeriodicFunctionMatrix}, HarmonicArray}","page":"Periodic matrix conversions","title":"Base.convert","text":"convert(PM1,A::PM2) -> B::PM1\n\nConvert the continuous-time periodic matrix A of type PM2 to the continuous-time periodic matrix B of type PM1,  where PM1 and PM2 are of types PeriodicFunctionMatrix, HarmonicArray, PeriodicTimeSeriesMatrix, PeriodicSwitchingMatrix,  PeriodicSymbolicMatrix or PeriodicFunctionMatrix. \n\n\n\n\n\n","category":"method"},{"location":"pmconv.html#PeriodicMatrices.ts2hr","page":"Periodic matrix conversions","title":"PeriodicMatrices.ts2hr","text":" ts2hr(A::PeriodicTimeSeriesMatrix; atol = 0, rtol, n, squeeze = true) -> Ahr::HarmonicArray\n\nCompute the harmonic (Fourier) approximation of a periodic matrix specified by a time series matrix.  The periodic matrix A(t) is specified as a continuous-time periodic time series matrix A,  with m matrices contained in the vector of matrices A.values, where A.values[k]  is the value of A(t) at time moment (k-1)T/m, with T = A.period being the period.  The resulting harmonic approximation Ahr(t) of A(t) has the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T)+As_i*sin(i*2*π*t/T) ) \n                i=1\n\nwhere A_0 is the constant term (the mean value), Ac_i and As_i are the   coefficient matrices of the i-th cosinus and sinus terms, respectively.  The order of the approximation p is determined using the maximum order specified by n  (default: n = (m-1)/2) and the absolute and relative tolerances atol and rtol, as follows: p is the minimum between n, (m-1)/2 and the maximum index k  such that Ac_k and/or As_k are nonzero. The tolerance used to assess nonzero elements is tol = max(atol, rtol*maxnorm), where  maxnorm is the maximum norm of the matrices contained in A.values. The default values of tolerances are atol = 0 and rtol = 10*p*ϵ, where ϵ is the working machine precision.\n\nThe resulting harmonic approximation Ahr(t) is returned in the harmonic array object Ahr  (see HarmonicArray). \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.pfm2hr","page":"Periodic matrix conversions","title":"PeriodicMatrices.pfm2hr","text":" pfm2hr(A::PeriodicFunctionMatrix; nsample, NyquistFreq) -> Ahr::HarmonicArray\n\nConvert a periodic function matrix into a harmonic array representation.  If A(t) is a periodic function matrix of period T, then the harmonic array representation Ahr is determined by applying the fast Fourier transform to the sampled arrays A(iΔ), i = 0, ..., k, where Δ = T/k is the sampling period and k is the number of samples specified by the keyword argument nsample = k (default: k = 128). If the Nyquist frequency f is specified via the keyword argument NyquistFreq = f, then k is chosen k = 2*f*T to avoid signal aliasing.     \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.ts2pfm","page":"Periodic matrix conversions","title":"PeriodicMatrices.ts2pfm","text":" ts2pfm(At::PeriodicTimeSeriesMatrix; method = \"linear\") -> A::PeriodicFunctionMatrix\n\nCompute the periodic function matrix corresponding to an interpolated periodic time series matrix.  For the given periodic time series matrix At, a periodic function matrix A(t) is defined as the  mapping A(t) = t -> etpf(t), where etpf(t) is a periodic interpolation/extrapolation object,   as provided in the Interpolations.jl  package.  The keyword parameter method specifies the interpolation/extrapolation method to be used as follows:\n\nmethod = \"constant\" - use periodic B-splines of degree 0 (periodic constant interpolation);\n\nmethod = \"linear\" - use periodic B-splines of degree 1 (periodic linear interpolation) (default);\n\nmethod = \"quadratic\" - use periodic B-splines of degree 2 (periodic quadratic interpolation); \n\nmethod = \"cubic\" - use periodic B-splines of degree 3 (periodic cubic interpolation). \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.hr2psm","page":"Periodic matrix conversions","title":"PeriodicMatrices.hr2psm","text":" hr2psm(Ahr::HarmonicArray, nrange) -> A::Matrix{Num}\n\nConvert a range of harmonic components nrange of the harmonic array Ahr to a symbolic matrix A.  The default range is nrange = 0:n, where n is the order of the maximum harmonics.  \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.psm2hr","page":"Periodic matrix conversions","title":"PeriodicMatrices.psm2hr","text":" psm2hr(A::PeriodicSymbolicMatrix; nsample, NyquistFreq) -> Ahr::HarmonicArray\n\nConvert a periodic symbolic matrix into a harmonic array representation.  If A(t) is a periodic symbolic matrix of period T, then the harmonic array representation Ahr is determined by applying the fast Fourier transform to the sampled arrays A(iΔ), i = 0, ..., k, where Δ = T/k is the sampling period and k is the number of samples specified by the keyword argument nsample = k (default: k = 128). If the Nyquist frequency f is specified via the keyword argument NyquistFreq = f, then k is chosen k = 2*f*T to avoid signal aliasing.     \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.pm2pa","page":"Periodic matrix conversions","title":"PeriodicMatrices.pm2pa","text":" pm2pa(At::PeriodicMatrix) -> A::PeriodicArray\n\nConvert a discrete-time periodic matrix object into a discrete-time periodic array object.\n\nThe discrete-time periodic matrix object At contains a   p-vector At of real matrices At[i], i = 1,..., p,  the associated time period T and the number of subperiods k. The resulting discrete-time periodic array object A of period T and number of subperiods k  is built from a m×n×p real array A, such that A[:,:,i]  contains At[i], for i = 1,..., p.  For non-constant dimensions, the resulting m and n are the maximum row and column dimensions, respectively, and the resulting component matrices A[:,:,i] contain At[i], appropriately padded with zero entries. \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.ffm2hr","page":"Periodic matrix conversions","title":"PeriodicMatrices.ffm2hr","text":" ffm2hr(Afun::FourierFunctionMatrix; atol = 0, rtol = √ϵ, squeeze = true) -> Ahr::HarmonicArray\n\nCompute the harmonic (Fourier) representation of a Fourier periodic matrix object. \n\nThe Fourier function matrix object Afun of period T is built using the Fourier series representation of a periodic matrix Afun(t) of subperiod T′ = T/k,  where each entry of Afun(t) has the form\n\n         p\n  a_0 +  ∑ ( ac_i*cos(i*t*2*π/T′)+as_i*sin(i*2*π*t/T′) ) ,\n        i=1\n\nwhere k ≥ 1 is the number of subperiods (default: k = 1).   \n\nThe harmonic array object Ahr of period T is built using the harmonic representation of a periodic matrix Ahr(t) of subperiod T′′ = T/k′ in the form\n\n                 p′\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T′′)+As_i*sin(i*2*π*t/T′′) ) ,\n                i=1\n\nwhere p′ is the maximum index j, such that Ac_j and/or As_j are nonzero. The tolerance used to assess nonzero elements is tol = max(atol, rtol*maxnorm), where  maxnorm is the maximum absolute value of the coefficients ac_i and as_i in Afun(t). The default values of tolerances are atol = 0 and rtol = √ϵ, where ϵ is the working machine precision. The resulting harmonic approximation Ahr(t) is returned in the harmonic array object Ahr  (see HarmonicArray). \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.ffm2psm","page":"Periodic matrix conversions","title":"PeriodicMatrices.ffm2psm","text":" ffm2psm(Af::FourierFunctionMatrix, nrange atol = 0, rtol = 10*n*ϵ,) -> A::Matrix{Num}\n\nConvert a range of harmonic components nrange of the Fourier function matrix Af to a symbolic matrix A.  The default range is nrange = 0:n, where n is the order of the maximum harmonics.  The tolerance used to assess nonzero coefficients is tol = max(atol, rtol*maxnorm), where  maxnorm is the maximum absolute value of the coefficients ac_i and as_i in Af(t). The default values of tolerances are atol = 0 and rtol = 10*n*ϵ, where ϵ is the working machine precision.\n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.hr2bt","page":"Periodic matrix conversions","title":"PeriodicMatrices.hr2bt","text":" hr2bt(Ahr::HarmonicArray, N; P, nperiod]) -> Abt::Matrix\n\nBuild the block Toeplitz matrix of a harmonic (Fourier) array representation of a periodic matrix. \n\nThe harmonic representation object Ahr of period T of a periodic matrix Ahr(t)  of subperiod T′ = T/k is in the form\n\n                 p\n Ahr(t) = A_0 +  ∑ ( Ac_i*cos(i*t*2*π/T′)+As_i*sin(i*2*π*t/T′) ) ,\n                i=1\n\nwhere k ≥ 1 is the number of subperiods. Ahr(t) can be equivalently expressed in the Fourier series representation form\n\n            p\n Ahr(t) =   ∑ A_i*exp(im*i*ωh*t) ,\n           i=-p\n\nwhere ωh = 2π/T′, A_i = (Ac_i-im*As_i)/2 and  A_{-i} = (Ac_i+im*As_i)/2.  N is the number of selected harmonic components (or Fourier modes) used for approximation.  The keyword parameter P is the number of full periods to be considered (default: P = 1) and nperiod is the number of subperiods to be considered, such that 1 ≤ nperiod ≤ k (default: nperiod = k). \n\nFor a given number N ≥ p, if the number of period is P = 1 and the number of subperiods is nperiod = 1,  then the banded block Toeplitz matrix Abt with (2N+1)×(2N+1) blocks is constructed\n\n       ( A_0  A_{-1} …  A_{-p}        0    )\n       ( A_1   A_0             ⋱           )\n       (  ⋮         ⋱            ⋱         )\n Abt = ( A_p             ⋱          A_{-p} )\n       (        ⋱           ⋱         ⋮    )\n       (  0        A_p      …         A_0  )\n\nIf N < p, then a truncated full block Toeplitz matrix is built using the first N harmonic components. \n\nGenerally, for given P ≥ 1 and  nperiod ≥ 1, the block Toeplitz matrix Abt is constructed with (2N*np+1)×(2N*np+1) blocks, with np = P*nperiod, such that each A_i is preceeded in its column by np-1 zero blocks,  each A_{-i} is preceeded in its row by np-1 zero blocks and all diagonal blocks are equal toA_0.   \n\n\n\n\n\n","category":"function"},{"location":"pmconv.html#PeriodicMatrices.hr2btupd","page":"Periodic matrix conversions","title":"PeriodicMatrices.hr2btupd","text":" hr2btupd(Ahr::HarmonicArray, N; P, nperiod, shift]) -> Ab::Matrix\n\nBuild the updated block Toeplitz matrix of a harmonic (Fourier) array representation of a periodic matrix. \n\nIf BT is the block Toeplitz matrix of the harmonic array representation of the n × n periodic matrix Ahr of subperiod T′  (see HarmonicArray) as constructed with hr2bt, then the updated matrix Ab = BT-NT is constructed,  with NT a block-diagonal matrix with n × n diagonal blocks. The k-th diagonal block of NT is the diagonal matrix im*(μ + k*ωh)*I, where μ is a shift specified via  the keyword parameter shift = μ (default: μ = 0)  and ωh is the base frequency computed as ωh = 2π*nperiod/(P*T′).  The value of shift must satisfy 0 ≤ μ ≤ ωh/2. \n\n\n\n\n\n","category":"function"}]
}
